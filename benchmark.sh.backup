#!/bin/bash

# ============================================================================ #
#                  MINISHELL ULTRA-STRICT PERFORMANCE TESTER v3.0              #
# ============================================================================ #

# Colors
BOLD='\033[1m'
DIM='\033[2m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
BG_GREEN='\033[42m'
BG_RED='\033[41m'
BG_YELLOW='\033[43m'
RESET='\033[0m'

# Configuration
MINISHELL="./minishell"
REPORT_DIR="benchmark_reports"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
REPORT_FILE="${REPORT_DIR}/benchmark_${TIMESTAMP}.txt"
TMP_DIR="/tmp/minishell_bench_$$"

# Counters
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_TOTAL=0
TEST_WARNINGS=0

# Error tracking
declare -a FAILED_TESTS
declare -a FAILED_DETAILS

# Performance tracking
declare -a PERF_TIMES_MS
declare -a PERF_TIMES_BASH

# Category-based result tracking
declare -A CATEGORY_NAMES
declare -A CATEGORY_PASSED
declare -A CATEGORY_FAILED
declare -A CATEGORY_TOTAL
declare -A CATEGORY_FAILED_TESTS
CURRENT_CATEGORY=""
CURRENT_CATEGORY_NUM=0

# Display mode
QUIET_MODE=0
TOTAL_TESTS_PLANNED=800

# ============================================================================ #
#                                  UTILITIES                                   #
# ============================================================================ #

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════╗
║                                                                          ║
║      ███╗   ███╗██╗███╗   ██╗██╗███╗   ██╗███████╗██╗  ██╗███████╗     ║
║      ████╗ ████║██║████╗  ██║██║████╗  ██║██╔════╝██║  ██║██╔════╝     ║
║      ██╔████╔██║██║██╔██╗ ██║██║██╔██╗ ██║███████╗███████║█████╗       ║
║      ██║╚██╔╝██║██║██║╚██╗██║██║██║╚██╗██║╚════██║██╔══██║██╔══╝       ║
║      ██║ ╚═╝ ██║██║██║ ╚████║██║██║ ╚████║███████║██║  ██║███████╗     ║
║      ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚══════╝     ║
║                                                                          ║
║                ULTRA-STRICT BENCHMARK v4.0 - 800+ Tests!                 ║
║             37 Test Categories | Every difference = FAILURE              ║
║                                                                          ║
╚══════════════════════════════════════════════════════════════════════════╝
EOF
    echo -e "${RESET}"
}

print_header() {
    echo -e "${CYAN}${BOLD}"
    echo "╔══════════════════════════════════════════════════════════════════════════╗"
    echo "║               MINISHELL ULTRA-STRICT BENCHMARK v4.0                      ║"
    echo "╚══════════════════════════════════════════════════════════════════════════╝"
    echo -e "${RESET}"
}

animate_loading() {
    local text="$1"
    local duration=${2:-2}

    echo -ne "${CYAN}${BOLD}$text${RESET} "

    for i in $(seq 1 $duration); do
        echo -ne "${YELLOW}▓${RESET}"
        sleep 0.15
    done

    echo -e " ${GREEN}✓${RESET}"
}

show_test_intro() {
    clear
    print_banner

    echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                  INITIALIZING BENCHMARK SUITE                           ${RESET}${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"

    animate_loading "Loading test configurations..." 3
    animate_loading "Preparing test environment..." 4
    animate_loading "Validating minishell binary..." 3
    animate_loading "Initializing test categories..." 4

    echo ""
    echo -e "${GREEN}${BOLD}✓ Ready to begin testing!${RESET}"
    echo -e "${CYAN}${BOLD}27 Test Categories${RESET} ${DIM}|${RESET} ${YELLOW}${BOLD}400+ Individual Tests${RESET} ${DIM}|${RESET} ${MAGENTA}${BOLD}Ultra-Strict Mode${RESET}\n"

    sleep 1
}

print_section() {
    local title="$1"
    local width=74
    local title_len=${#title}
    local padding=$(( (width - title_len - 2) / 2 ))

    # Extract test number from "TEST X: Description" format and initialize category
    if [[ "$title" =~ TEST[[:space:]]+([0-9]+):[[:space:]]*(.+) ]]; then
        local test_num="${BASH_REMATCH[1]}"
        local test_desc="${BASH_REMATCH[2]}"
        # Remove leading/trailing whitespace
        test_num=$(echo "$test_num" | tr -d '[:space:]')
        test_desc=$(echo "$test_desc" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        print_category_header "$test_desc" "$test_num"
    fi

    # Only show section header in verbose mode
    if [ $QUIET_MODE -eq 1 ]; then
        return
    fi

    echo ""
    echo -e "${BLUE}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    printf "${BLUE}${BOLD}║${RESET}${WHITE}${BOLD}%*s%s%*s${RESET}${BLUE}${BOLD}║${RESET}\n" $padding "" "$title" $((width - title_len - padding)) ""
    echo -e "${BLUE}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
}

print_section_with_stats() {
    local title="$1"
    local current="$2"
    local total="$3"

    echo ""
    echo -e "${BLUE}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    printf "${BLUE}${BOLD}║${RESET} ${YELLOW}${BOLD}%s${RESET}  ${DIM}│${RESET}  ${CYAN}Category %2d/%2d${RESET}  ${DIM}│${RESET}  " "$title" "$current" "$total"

    local percentage=0
    if [ $TESTS_TOTAL -gt 0 ] && [ $TESTS_PASSED -gt 0 ]; then
        percentage=$((TESTS_PASSED * 100 / TESTS_TOTAL))
    fi

    printf "${GREEN}✓ %d${RESET} ${RED}✗ %d${RESET}  ${DIM}│${RESET}  ${MAGENTA}%d%%${RESET} " $TESTS_PASSED $TESTS_FAILED $percentage

    # Calculate remaining space
    local title_len=${#title}
    local stats_len=48  # Approximate length of stats
    local total_len=$((title_len + stats_len))
    local padding=$((72 - total_len))

    printf "%${padding}s${BLUE}${BOLD}║${RESET}\n" ""
    echo -e "${BLUE}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
}

print_test_header() {
    echo -e "${YELLOW}${BOLD}▸ $1${RESET}"
}

print_test_subheader() {
    echo -e "${DIM}  → $1${RESET}"
}

print_pass() {
    if [ $QUIET_MODE -eq 1 ]; then
        show_live_progress_bar
        return
    fi
    echo -e "${GREEN}  ✓${RESET} $1"
}

print_fail() {
    if [ $QUIET_MODE -eq 1 ]; then
        show_live_progress_bar
        return
    fi
    echo -e "${RED}  ✗${RESET} $1"
}

print_warn() {
    echo -e "${YELLOW}  ⚠${RESET} $1"
}

print_info() {
    echo -e "${CYAN}  ℹ${RESET} $1"
}

print_error_detail() {
    local test_name="$1"
    local expected="$2"
    local got="$3"

    echo -e "${RED}${BOLD}    ┌─ Error Details:${RESET}"
    echo -e "${RED}    │${RESET} ${DIM}Expected:${RESET} ${expected:0:60}"
    echo -e "${RED}    │${RESET} ${DIM}Got:     ${RESET} ${got:0:60}"
    echo -e "${RED}    └─${RESET}"
}

print_progress_bar() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((width * current / total))
    local empty=$((width - filled))

    # Color based on percentage
    local bar_color=$GREEN
    if [ $percentage -lt 100 ]; then
        bar_color=$YELLOW
    fi
    if [ $percentage -lt 80 ]; then
        bar_color=$YELLOW
    fi
    if [ $percentage -lt 60 ]; then
        bar_color=$RED
    fi

    printf "\r${CYAN}Progress: [${RESET}"
    printf "${bar_color}%${filled}s${RESET}" | tr ' ' '█'
    printf "${DIM}%${empty}s${RESET}" | tr ' ' '░'
    printf "${CYAN}] ${WHITE}${BOLD}%3d%%${RESET} ${DIM}(%d/%d)${RESET}" $percentage $current $total
}

print_category_header() {
    local category="$1"
    local test_num="$2"

    # Clean and validate test number
    test_num=$(echo "$test_num" | tr -d '[:space:]')

    # Initialize category tracking
    CURRENT_CATEGORY="$category"
    CURRENT_CATEGORY_NUM="$test_num"
    CATEGORY_NAMES["$test_num"]="$category"
    CATEGORY_PASSED["$test_num"]=0
    CATEGORY_FAILED["$test_num"]=0
    CATEGORY_TOTAL["$test_num"]=0
    CATEGORY_FAILED_TESTS["$test_num"]=""

    if [ $QUIET_MODE -eq 1 ]; then
        show_live_progress_bar
        return
    fi

    echo ""
    echo -e "${BLUE}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    printf "${BLUE}${BOLD}║${RESET} ${YELLOW}${BOLD}TEST #%2d${RESET} ${CYAN}│${RESET} %-58s ${BLUE}${BOLD}║${RESET}\n" "$test_num" "$category"
    echo -e "${BLUE}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
}

print_category_footer() {
    local passed=$1
    local failed=$2
    local total=$3
    local duration=$4

    if [ $QUIET_MODE -eq 1 ]; then
        return
    fi

    local percentage=0
    if [ $total -gt 0 ]; then
        percentage=$((passed * 100 / total))
    fi

    echo ""
    echo -e "${DIM}${BOLD}────────────────────────────────────────────────────────────────────────────${RESET}"
    printf "${DIM}│${RESET} "

    if [ $failed -eq 0 ]; then
        printf "${GREEN}${BOLD}✓ ALL PASSED${RESET}"
    else
        printf "${YELLOW}${BOLD}⚠ %d FAILED${RESET}" $failed
    fi

    printf " ${DIM}│${RESET} "
    printf "${CYAN}%d/%d tests${RESET}" $passed $total
    printf " ${DIM}│${RESET} "
    printf "${MAGENTA}%d%%${RESET}" $percentage

    if [ -n "$duration" ]; then
        printf " ${DIM}│${RESET} "
        printf "${YELLOW}%.2fs${RESET}" $duration
    fi

    echo ""
    echo -e "${DIM}${BOLD}────────────────────────────────────────────────────────────────────────────${RESET}"
}

print_live_stats() {
    local current_test=$1
    local total_tests=$2

    echo -e "\n${CYAN}${BOLD}╭─────────────────── LIVE STATISTICS ────────────────────╮${RESET}"
    printf "${CYAN}${BOLD}│${RESET} ${GREEN}✓ Passed:${RESET} %-6d ${CYAN}${BOLD}│${RESET} ${RED}✗ Failed:${RESET} %-6d ${CYAN}${BOLD}│${RESET} ${YELLOW}⚠ Warnings:${RESET} %-4d ${CYAN}${BOLD}│${RESET}\n" $TESTS_PASSED $TESTS_FAILED $TEST_WARNINGS

    local percentage=0
    if [ $TESTS_TOTAL -gt 0 ]; then
        percentage=$((TESTS_PASSED * 100 / TESTS_TOTAL))
    fi

    printf "${CYAN}${BOLD}│${RESET} ${WHITE}Total:${RESET} %-8d ${CYAN}${BOLD}│${RESET} ${MAGENTA}Success Rate:${RESET} %-6d%% ${CYAN}${BOLD}│${RESET} ${DIM}Progress: %d/%d${RESET}  ${CYAN}${BOLD}│${RESET}\n" $TESTS_TOTAL $percentage $current_test $total_tests
    echo -e "${CYAN}${BOLD}╰────────────────────────────────────────────────────────╯${RESET}\n"
}

show_live_progress_bar() {
    if [ $QUIET_MODE -eq 0 ]; then
        return
    fi

    local percentage=0
    if [ $TOTAL_TESTS_PLANNED -gt 0 ]; then
        percentage=$((TESTS_TOTAL * 100 / TOTAL_TESTS_PLANNED))
    fi

    local bar_width=40
    local filled=$((bar_width * TESTS_TOTAL / TOTAL_TESTS_PLANNED))
    if [ $filled -gt $bar_width ]; then filled=$bar_width; fi
    local empty=$((bar_width - filled))

    local success_rate=0
    if [ $TESTS_TOTAL -gt 0 ]; then
        success_rate=$((TESTS_PASSED * 100 / TESTS_TOTAL))
    fi

    # Choose color based on success rate
    local bar_color=$GREEN
    if [ $success_rate -lt 100 ]; then bar_color=$YELLOW; fi
    if [ $success_rate -lt 80 ]; then bar_color=$RED; fi

    # Truncate category name to fit (increased from 30 to 42)
    local cat_display="${CURRENT_CATEGORY:0:42}"

    # Clear and redraw (simple version)
    printf "\r\033[K"
    printf "${CYAN}[${RESET}%-42s${CYAN}]${RESET} [" "$cat_display"
    printf "${bar_color}%${filled}s${RESET}" | tr ' ' '█'
    printf "${DIM}%${empty}s${RESET}" | tr ' ' '░'
    printf "] ${WHITE}%3d%%${RESET} ${CYAN}%4d${RESET}/${CYAN}%d${RESET} ${GREEN}✓%4d${RESET} ${RED}✗%4d${RESET} ${MAGENTA}%3d%%${RESET}" \
        $percentage $TESTS_TOTAL $TOTAL_TESTS_PLANNED $TESTS_PASSED $TESTS_FAILED $success_rate
}

print_test_result_enhanced() {
    local status=$1
    local test_name=$2
    local details=$3

    if [ "$status" = "pass" ]; then
        printf "  ${GREEN}●${RESET} ${GREEN}✓${RESET} %-60s ${GREEN}${BOLD}PASS${RESET}\n" "$test_name"
    elif [ "$status" = "fail" ]; then
        printf "  ${RED}●${RESET} ${RED}✗${RESET} %-60s ${RED}${BOLD}FAIL${RESET}\n" "$test_name"
        if [ -n "$details" ]; then
            echo -e "${DIM}    └─ $details${RESET}"
        fi
    elif [ "$status" = "warn" ]; then
        printf "  ${YELLOW}●${RESET} ${YELLOW}⚠${RESET} %-60s ${YELLOW}${BOLD}WARN${RESET}\n" "$test_name"
    elif [ "$status" = "skip" ]; then
        printf "  ${DIM}●${RESET} ${DIM}⊘${RESET} %-60s ${DIM}${BOLD}SKIP${RESET}\n" "$test_name"
    fi
}

draw_success_rate_bar() {
    local passed=$1
    local total=$2
    local width=60

    if [ $total -eq 0 ]; then
        return
    fi

    local percentage=$((passed * 100 / total))
    local filled=$((width * passed / total))
    local empty=$((width - filled))

    local color=$GREEN
    if [ $percentage -lt 100 ]; then
        color=$YELLOW
    fi
    if [ $percentage -lt 80 ]; then
        color=$YELLOW
    fi
    if [ $percentage -lt 60 ]; then
        color=$RED
    fi

    echo -e "\n${WHITE}${BOLD}Success Rate Visualization:${RESET}"
    printf "  ["
    printf "${color}%${filled}s${RESET}" | tr ' ' '█'
    printf "${DIM}%${empty}s${RESET}" | tr ' ' '░'
    printf "] ${WHITE}${BOLD}%d%%${RESET}\n" $percentage
}

print_test_summary_box() {
    local category="$1"
    local passed=$2
    local total=$3
    local status_icon="✓"
    local status_color=$GREEN

    if [ $passed -lt $total ]; then
        status_icon="⚠"
        status_color=$YELLOW
    fi

    if [ $((passed * 100 / total)) -lt 60 ]; then
        status_icon="✗"
        status_color=$RED
    fi

    printf "  ${status_color}${BOLD}[%s]${RESET} %-50s ${CYAN}%3d${RESET}/${CYAN}%3d${RESET}\n" "$status_icon" "$category" $passed $total
}

draw_table_header() {
    echo -e "${CYAN}╔════════════════════════════════════╦══════════════╦══════════════╦═══════════╗${RESET}"
    echo -e "${CYAN}║${RESET}${BOLD}              Test Name             ${RESET}${CYAN}║${RESET}${BOLD}  Minishell   ${RESET}${CYAN}║${RESET}${BOLD}     Bash     ${RESET}${CYAN}║${RESET}${BOLD}   Ratio   ${RESET}${CYAN}║${RESET}"
    echo -e "${CYAN}╠════════════════════════════════════╬══════════════╬══════════════╬═══════════╣${RESET}"
}

draw_table_row() {
    local name="$1"
    local ms_time="$2"
    local bash_time="$3"
    local ratio=""

    if [ "$bash_time" != "N/A" ] && [ "$bash_time" -gt 0 ]; then
        ratio=$(echo "scale=2; $ms_time * 100 / $bash_time" | bc)"%"
    else
        ratio="N/A"
    fi

    printf "${CYAN}║${RESET} %-34s ${CYAN}║${RESET} ${YELLOW}%10s ms${RESET} ${CYAN}║${RESET} ${GREEN}%10s ms${RESET} ${CYAN}║${RESET} ${MAGENTA}%9s${RESET} ${CYAN}║${RESET}\n" \
        "$name" "$ms_time" "$bash_time" "$ratio"
}

draw_table_footer() {
    echo -e "${CYAN}╚════════════════════════════════════╩══════════════╩══════════════╩═══════════╝${RESET}"
}

check_minishell() {
    if [ ! -f "$MINISHELL" ]; then
        print_fail "Minishell executable not found!"
        echo -e "${YELLOW}  Run 'make' first to compile the project.${RESET}"
        exit 1
    fi

    if [ ! -x "$MINISHELL" ]; then
        print_fail "Minishell is not executable!"
        exit 1
    fi
}

init_report() {
    mkdir -p "$REPORT_DIR"
    mkdir -p "$TMP_DIR"

    cat > "$REPORT_FILE" << EOF
╔══════════════════════════════════════════════════════════════════════════╗
║                  MINISHELL PERFORMANCE REPORT                            ║
║                  Date: $(date)                           ║
╚══════════════════════════════════════════════════════════════════════════╝

EOF
}

cleanup() {
    rm -rf "$TMP_DIR"
    rm -f /tmp/minishell_test_* 2>/dev/null
}

trap cleanup EXIT INT TERM

# ============================================================================ #
#                            MEASUREMENT FUNCTIONS                             #
# ============================================================================ #

measure_time_ms() {
    local shell=$1
    local input_file=$2

    local start=$(perl -MTime::HiRes=time -e 'printf "%.0f\n", time()*1000')

    if [ "$shell" = "$MINISHELL" ]; then
        timeout 10 bash -c "cat '$input_file' | $shell > /dev/null 2>&1" || return 1
    else
        timeout 10 bash -c "cat '$input_file' | bash --norc --noprofile > /dev/null 2>&1" || return 1
    fi

    local end=$(perl -MTime::HiRes=time -e 'printf "%.0f\n", time()*1000')
    echo $((end - start))
}

run_and_compare() {
    local cmd=$1
    local test_name=$2
    local show_output=${3:-1}

    ((TESTS_TOTAL++))

    # Update category counters
    if [ -n "$CURRENT_CATEGORY_NUM" ]; then
        ((CATEGORY_TOTAL["$CURRENT_CATEGORY_NUM"]++))
    fi

    echo -e "$cmd\nexit" > "$TMP_DIR/input.txt"

    timeout 10 bash -c "cat '$TMP_DIR/input.txt' | $MINISHELL 2>&1" > "$TMP_DIR/minishell_out.txt" 2>&1
    local ms_exit=$?

    echo "$cmd" | bash --norc --noprofile > "$TMP_DIR/bash_out.txt" 2>&1
    local bash_exit=$?

    grep -v "^minishell" "$TMP_DIR/minishell_out.txt" | grep -v "^\$" | grep -v "^>" > "$TMP_DIR/minishell_clean.txt" 2>/dev/null || touch "$TMP_DIR/minishell_clean.txt"

    if [ $ms_exit -eq 124 ]; then
        print_fail "$test_name - ${RED}${BOLD}TIMEOUT${RESET}"
        FAILED_TESTS+=("$test_name")
        FAILED_DETAILS+=("TIMEOUT after 10 seconds")
        echo "  ✗ $test_name - TIMEOUT" >> "$REPORT_FILE"
        ((TESTS_FAILED++))

        # Update category counters
        if [ -n "$CURRENT_CATEGORY_NUM" ]; then
            ((CATEGORY_FAILED["$CURRENT_CATEGORY_NUM"]++))
            CATEGORY_FAILED_TESTS["$CURRENT_CATEGORY_NUM"]+="$test_name|"
        fi
        return 1
    fi

    # ULTRA-STRICT MODE: Any difference from bash is a FAILURE
    if diff -q "$TMP_DIR/minishell_clean.txt" "$TMP_DIR/bash_out.txt" > /dev/null 2>&1; then
        print_pass "$test_name"
        echo "  ✓ $test_name" >> "$REPORT_FILE"
        ((TESTS_PASSED++))

        # Update category counters
        if [ -n "$CURRENT_CATEGORY_NUM" ]; then
            ((CATEGORY_PASSED["$CURRENT_CATEGORY_NUM"]++))
        fi
        return 0
    else
        local expected=$(cat "$TMP_DIR/bash_out.txt" 2>/dev/null | head -5 || echo "(empty)")
        local got=$(cat "$TMP_DIR/minishell_clean.txt" 2>/dev/null | head -5 || echo "(empty)")

        print_fail "$test_name - ${RED}${BOLD}OUTPUT MISMATCH${RESET}"
        if [ $show_output -eq 1 ]; then
            print_error_detail "$test_name" "$expected" "$got"
        fi

        FAILED_TESTS+=("$test_name")
        FAILED_DETAILS+=("Expected: '$expected' | Got: '$got'")

        echo "  ✗ $test_name - OUTPUT MISMATCH" >> "$REPORT_FILE"
        echo "    Expected: $expected" >> "$REPORT_FILE"
        echo "    Got:      $got" >> "$REPORT_FILE"
        ((TESTS_FAILED++))

        # Update category counters
        if [ -n "$CURRENT_CATEGORY_NUM" ]; then
            ((CATEGORY_FAILED["$CURRENT_CATEGORY_NUM"]++))
            CATEGORY_FAILED_TESTS["$CURRENT_CATEGORY_NUM"]+="$test_name|"
        fi
        return 1
    fi
}

# ============================================================================ #
#                                TEST FUNCTIONS                                #
# ============================================================================ #

test_startup_performance() {
    print_section "TEST 1: Startup Performance Analysis"
    echo "Test 1: Startup Performance" >> "$REPORT_FILE"

    print_test_header "Measuring shell startup time with various conditions..."

    local iterations=30
    local total_ms=0
    local total_bash=0
    local min_ms=999999
    local max_ms=0
    local min_bash=999999
    local max_bash=0

    echo "exit" > "$TMP_DIR/exit_only.txt"

    for i in $(seq 1 $iterations); do
        print_progress_bar $i $iterations

        local time_ms=$(measure_time_ms "$MINISHELL" "$TMP_DIR/exit_only.txt")
        if [ $? -eq 0 ] && [ -n "$time_ms" ]; then
            total_ms=$((total_ms + time_ms))
            [ $time_ms -lt $min_ms ] && min_ms=$time_ms
            [ $time_ms -gt $max_ms ] && max_ms=$time_ms
        fi

        local time_bash=$(measure_time_ms "bash" "$TMP_DIR/exit_only.txt")
        if [ $? -eq 0 ] && [ -n "$time_bash" ]; then
            total_bash=$((total_bash + time_bash))
            [ $time_bash -lt $min_bash ] && min_bash=$time_bash
            [ $time_bash -gt $max_bash ] && max_bash=$time_bash
        fi
    done

    echo ""

    local avg_ms=$((total_ms / iterations))
    local avg_bash=$((total_bash / iterations))

    echo ""
    draw_table_header
    draw_table_row "Average" "$avg_ms" "$avg_bash"
    draw_table_row "Minimum" "$min_ms" "$min_bash"
    draw_table_row "Maximum" "$max_ms" "$max_bash"
    draw_table_footer

    echo "" >> "$REPORT_FILE"
    echo "  Iterations: $iterations" >> "$REPORT_FILE"
    echo "  Minishell - Avg: ${avg_ms}ms, Min: ${min_ms}ms, Max: ${max_ms}ms" >> "$REPORT_FILE"
    echo "  Bash      - Avg: ${avg_bash}ms, Min: ${min_bash}ms, Max: ${max_bash}ms" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
}

test_echo_hardcore() {
    print_section "TEST 2: Echo Command - Hardcore Testing"
    echo "Test 2: Echo Command Hardcore" >> "$REPORT_FILE"

    print_test_header "Testing echo with various argument combinations..."

    local tests=(
        "echo hello"
        "echo hello world"
        "echo 'hello world'"
        "echo \"hello world\""
        "echo 'hello' \"world\""
        "echo -n test"
        "echo -n -n test"
        "echo -n"
        "echo"
        "echo ''"
        "echo \"\""
        "echo test1 test2 test3 test4 test5"
        "echo -n hello world"
        "echo 'test with    spaces'"
        "echo \"test with    spaces\""
        "echo \$HOME"
        "echo '\$HOME'"
        "echo \"\$HOME\""
        "echo \$PATH"
        "echo \$USER"
        "echo \$?"
        "echo test\$HOME"
        "echo test\\\$HOME"
        "echo 'multiple' 'quoted' 'strings'"
        "echo \"multiple\" \"quoted\" \"strings\""
        "echo a b c d e f g h i j k l m n o p q r s t u v w x y z"
        "echo 1 2 3 4 5 6 7 8 9 10"
        "echo !@#%^&*()"
        "echo '!@#%^&*()'"
        "echo test	with	tabs"
        "echo -n -n -n test"
        "echo --help"
        "echo -e test"
        "echo -E test"
    )

    local count=0
    for test_cmd in "${tests[@]}"; do
        ((count++))
        run_and_compare "$test_cmd" "echo #$count: ${test_cmd:0:35}"
    done

    echo "" >> "$REPORT_FILE"
}

test_echo_extreme() {
    print_section "TEST 3: Echo - Extreme Cases"
    echo "Test 3: Echo Extreme Cases" >> "$REPORT_FILE"

    print_test_header "Testing echo with extreme inputs..."

    # Very long string
    local long_str=$(printf 'A%.0s' {1..1000})
    run_and_compare "echo $long_str" "echo with 1000 chars"

    # Very long string with spaces
    local long_spaces=$(printf 'word%.0s ' {1..100})
    run_and_compare "echo $long_spaces" "echo with 100 words"

    # Many arguments
    local many_args=$(seq 1 100 | tr '\n' ' ')
    run_and_compare "echo $many_args" "echo with 100 arguments"

    # 500 arguments
    local very_many_args=$(seq 1 500 | tr '\n' ' ')
    run_and_compare "echo $very_many_args" "echo with 500 arguments"

    # Unicode and special chars
    run_and_compare "echo '日本語 français español'" "echo with unicode"
    run_and_compare "echo '¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿'" "echo with extended ASCII"

    # Nested quotes
    run_and_compare "echo \"'test'\"" "echo with nested quotes 1"
    run_and_compare "echo '\"test\"'" "echo with nested quotes 2"
    run_and_compare "echo \"'\"test\"'\"" "echo with complex nested quotes"

    # Empty variations
    run_and_compare "echo '' '' ''" "echo with multiple empty strings"
    run_and_compare "echo \"\" \"\" \"\"" "echo with multiple empty strings 2"

    # Backslashes
    run_and_compare "echo \\\\\\\\" "echo with backslashes"
    run_and_compare "echo 'test\\ntest'" "echo with escaped newline"

    echo "" >> "$REPORT_FILE"
}

test_syntax_errors() {
    print_section "TEST 4: Syntax Error Handling"
    echo "Test 4: Syntax Errors" >> "$REPORT_FILE"

    print_test_header "Testing syntax error detection and handling..."

    local syntax_tests=(
        "echo 'unclosed quote"
        "echo \"unclosed double quote"
        "echo 'multiple 'quotes' test'"
        "| echo test"
        "echo test |"
        "echo test | | cat"
        "> output.txt"
        "< input.txt"
        "echo test > > output.txt"
        "echo test < < input.txt"
        "echo test >>"
        "echo test <<"
        "echo test &&"
        "echo test ||"
        "echo test ;"
        "; echo test"
        "echo test &"
        "& echo test"
    )

    for syntax_test in "${syntax_tests[@]}"; do
        echo -e "$syntax_test\nexit" > "$TMP_DIR/test.txt"

        timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"
        local exit_code=$?

        ((TESTS_TOTAL++))

        if [ $exit_code -eq 0 ] || [ $exit_code -eq 124 ]; then
            print_pass "Syntax error handled: ${syntax_test:0:30}"
            echo "  ✓ Syntax: $syntax_test" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "Crashed on syntax error: ${syntax_test:0:30}"
            FAILED_TESTS+=("Syntax: $syntax_test")
            FAILED_DETAILS+=("Shell crashed on invalid syntax")
            echo "  ✗ Syntax: $syntax_test (crashed)" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    done

    echo "" >> "$REPORT_FILE"
}

test_pipes_comprehensive() {
    print_section "TEST 5: Pipes - Comprehensive Testing"
    echo "Test 5: Pipes Comprehensive" >> "$REPORT_FILE"

    print_test_header "Testing pipes with increasing complexity..."

    seq 1 1000 > "$TMP_DIR/numbers.txt"
    echo "Lorem ipsum dolor sit amet consectetur adipiscing elit" > "$TMP_DIR/text.txt"

    local pipe_tests=(
        "echo hello | cat"
        "echo hello | cat | cat"
        "echo hello | cat | cat | cat"
        "echo hello | cat | cat | cat | cat"
        "echo hello | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/numbers.txt | head -10"
        "cat $TMP_DIR/numbers.txt | tail -10"
        "cat $TMP_DIR/numbers.txt | grep 5"
        "cat $TMP_DIR/numbers.txt | grep 5 | wc -l"
        "cat $TMP_DIR/numbers.txt | grep 5 | head -5"
        "cat $TMP_DIR/numbers.txt | grep 5 | tail -5"
        "echo test | grep test"
        "echo test | grep test | cat"
        "echo abc def ghi | cat | cat | cat"
        "cat $TMP_DIR/text.txt | cat | cat"
        "ls | grep bench"
        "ls -la | head -5"
        "echo 1 2 3 | cat | cat | cat | cat"
        "cat $TMP_DIR/numbers.txt | head -50 | tail -10 | grep 4"
        "echo test | cat | grep test | cat | cat"
    )

    echo ""
    draw_table_header

    for test_cmd in "${pipe_tests[@]}"; do
        echo -e "$test_cmd\nexit" > "$TMP_DIR/pipe_test.txt"
        local time_ms=$(measure_time_ms "$MINISHELL" "$TMP_DIR/pipe_test.txt" 2>/dev/null || echo "0")
        local time_bash=$(measure_time_ms "bash" "$TMP_DIR/pipe_test.txt" 2>/dev/null || echo "1")

        local test_name="${test_cmd:0:34}"
        draw_table_row "$test_name" "$time_ms" "$time_bash"

        echo "$test_cmd" >> "$REPORT_FILE"
        echo "  Minishell: ${time_ms}ms | Bash: ${time_bash}ms" >> "$REPORT_FILE"
    done

    draw_table_footer
    echo "" >> "$REPORT_FILE"
}

test_redirections_hardcore() {
    print_section "TEST 6: Redirections - Hardcore Testing"
    echo "Test 6: Redirections Hardcore" >> "$REPORT_FILE"

    print_test_header "Testing all redirection combinations..."

    echo "test line 1" > "$TMP_DIR/input.txt"
    echo "test line 2" >> "$TMP_DIR/input.txt"
    echo "test line 3" >> "$TMP_DIR/input.txt"

    # Output redirection
    echo -e "echo hello > $TMP_DIR/out1.txt\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        if [ -f "$TMP_DIR/out1.txt" ] && grep -q "hello" "$TMP_DIR/out1.txt"; then
            print_pass "Output redirection (>)"
            echo "  ✓ output redirection >" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "Output redirection (>) - File not created or wrong content"
            FAILED_TESTS+=("Output redirection >")
            FAILED_DETAILS+=("File not created or wrong content")
            echo "  ✗ output redirection >" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    fi
    ((TESTS_TOTAL++))

    # Input redirection
    echo -e "cat < $TMP_DIR/input.txt\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/cat_result.txt 2>&1"
    if grep -q "test line" "$TMP_DIR/cat_result.txt"; then
        print_pass "Input redirection (<)"
        echo "  ✓ input redirection <" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Input redirection (<) - Content not read"
        FAILED_TESTS+=("Input redirection <")
        FAILED_DETAILS+=("Input file content not read correctly")
        echo "  ✗ input redirection <" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Append
    echo -e "echo line1 > $TMP_DIR/append.txt\necho line2 >> $TMP_DIR/append.txt\necho line3 >> $TMP_DIR/append.txt\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        if [ -f "$TMP_DIR/append.txt" ]; then
            local lines=$(wc -l < "$TMP_DIR/append.txt" | tr -d ' ')
            if [ "$lines" -ge 2 ]; then
                print_pass "Append redirection (>>) - $lines lines"
                echo "  ✓ append redirection >>" >> "$REPORT_FILE"
                ((TESTS_PASSED++))
            else
                print_fail "Append redirection (>>) - Only $lines line(s)"
                FAILED_TESTS+=("Append redirection >>")
                FAILED_DETAILS+=("Expected 3 lines, got $lines")
                echo "  ✗ append redirection >>" >> "$REPORT_FILE"
                ((TESTS_FAILED++))
            fi
        fi
    fi
    ((TESTS_TOTAL++))

    # Multiple redirections
    echo -e "cat < $TMP_DIR/input.txt > $TMP_DIR/output.txt\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        if [ -f "$TMP_DIR/output.txt" ] && grep -q "test line" "$TMP_DIR/output.txt"; then
            print_pass "Multiple redirections (< >)"
            echo "  ✓ multiple redirections" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "Multiple redirections (< >)"
            FAILED_TESTS+=("Multiple redirections")
            FAILED_DETAILS+=("Combined redirections failed")
            echo "  ✗ multiple redirections" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    fi
    ((TESTS_TOTAL++))

    # Redirection with pipes
    echo -e "echo test | cat > $TMP_DIR/pipe_out.txt\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        if [ -f "$TMP_DIR/pipe_out.txt" ] && grep -q "test" "$TMP_DIR/pipe_out.txt"; then
            print_pass "Pipe with redirection (| >)"
            echo "  ✓ pipe with redirection" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "Pipe with redirection (| >)"
            FAILED_TESTS+=("Pipe with redirection")
            FAILED_DETAILS+=("Pipe + redirection combination failed")
            echo "  ✗ pipe with redirection" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    fi
    ((TESTS_TOTAL++))

    # Overwrite test
    echo "old content" > "$TMP_DIR/overwrite.txt"
    echo -e "echo new content > $TMP_DIR/overwrite.txt\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        if grep -q "new content" "$TMP_DIR/overwrite.txt" && ! grep -q "old content" "$TMP_DIR/overwrite.txt"; then
            print_pass "Overwrite existing file"
            echo "  ✓ overwrite test" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "Overwrite existing file - Old content still present"
            FAILED_TESTS+=("Overwrite file")
            FAILED_DETAILS+=("File not properly overwritten")
            echo "  ✗ overwrite test" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    fi
    ((TESTS_TOTAL++))

    # Redirection to nonexistent path
    echo -e "echo test > /nonexistent/path/file.txt\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"
    if [ $? -eq 0 ]; then
        print_pass "Error handling: redirect to invalid path"
        echo "  ✓ invalid path handling" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_warn "Invalid path redirection - shell crashed"
        echo "  ? invalid path handling" >> "$REPORT_FILE"
        ((TEST_WARNINGS++))
    fi
    ((TESTS_TOTAL++))

    echo "" >> "$REPORT_FILE"
}

test_environment_variables_extensive() {
    print_section "TEST 7: Environment Variables - Extensive Testing"
    echo "Test 7: Environment Variables Extensive" >> "$REPORT_FILE"

    print_test_header "Testing environment variable expansion..."

    # Standard variables
    local var_tests=(
        "echo \$PATH"
        "echo \$HOME"
        "echo \$USER"
        "echo \$PWD"
        "echo \$SHELL"
        "echo \$?"
        "echo \$0"
        "echo test\$HOME"
        "echo \$HOME/test"
        "echo \$HOME\$PATH"
        "echo '\$HOME'"
        "echo \"\$HOME\""
        "echo \$NONEXISTENT"
        "echo \$NONEXISTENT_VAR_123"
        "echo test\$NONEXISTENT"
        "echo \$PATH\$HOME\$USER"
    )

    for var_test in "${var_tests[@]}"; do
        echo -e "$var_test\nexit" > "$TMP_DIR/test.txt"
        timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"

        if [ -s "$TMP_DIR/result.txt" ] || [[ "$var_test" == *"NONEXISTENT"* ]]; then
            print_pass "$var_test"
            echo "  ✓ $var_test" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "$var_test - No output"
            FAILED_TESTS+=("$var_test")
            FAILED_DETAILS+=("Variable expansion produced no output")
            echo "  ✗ $var_test" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
        ((TESTS_TOTAL++))
    done

    # Exit status tests
    echo -e "ls /nonexistent\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    if grep -q "[0-9]" "$TMP_DIR/result.txt"; then
        print_pass "Exit status after error"
        echo "  ✓ exit status test" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_warn "Exit status after error - uncertain"
        echo "  ? exit status test" >> "$REPORT_FILE"
        ((TEST_WARNINGS++))
    fi
    ((TESTS_TOTAL++))

    echo "" >> "$REPORT_FILE"
}

test_quotes_comprehensive() {
    print_section "TEST 8: Quote Handling - Comprehensive"
    echo "Test 8: Quote Handling Comprehensive" >> "$REPORT_FILE"

    print_test_header "Testing quote combinations..."

    local quote_tests=(
        "echo 'hello'"
        "echo \"hello\""
        "echo 'hello world'"
        "echo \"hello world\""
        "echo 'hello' world"
        "echo \"hello\" world"
        "echo hello 'world'"
        "echo hello \"world\""
        "echo 'hello' 'world'"
        "echo \"hello\" \"world\""
        "echo 'hello' \"world\""
        "echo \"hello\" 'world'"
        "echo ''"
        "echo \"\""
        "echo '' ''"
        "echo \"\" \"\""
        "echo 'test \$HOME'"
        "echo \"test \$HOME\""
        "echo '\$USER'"
        "echo \"\$USER\""
        "echo 'test\"quote'"
        "echo \"test'quote\""
        "echo ''''"
        "echo \"\"\"\""
        "echo 'a''b'"
        "echo \"a\"\"b\""
        "echo 'test with \"double\" inside'"
        "echo \"test with 'single' inside\""
        "echo 'test\\nwith\\nbackslash'"
        "echo \"test\\nwith\\nbackslash\""
    )

    local count=0
    for quote_test in "${quote_tests[@]}"; do
        ((count++))
        run_and_compare "$quote_test" "quote #$count: ${quote_test:0:30}"
    done

    echo "" >> "$REPORT_FILE"
}

test_edge_cases_extreme() {
    print_section "TEST 9: Edge Cases - Extreme Testing"
    echo "Test 9: Edge Cases Extreme" >> "$REPORT_FILE"

    print_test_header "Testing extreme edge cases..."

    # Empty inputs
    echo -e "\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "Empty line"
        echo "  ✓ empty line" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Empty line - Shell crashed"
        FAILED_TESTS+=("Empty line")
        FAILED_DETAILS+=("Shell crashed on empty input")
        echo "  ✗ empty line" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Multiple empty lines
    echo -e "\n\n\n\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "Multiple empty lines"
        echo "  ✓ multiple empty lines" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Multiple empty lines - Shell crashed"
        echo "  ✗ multiple empty lines" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Only spaces
    echo -e "     \nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "Line with only spaces"
        echo "  ✓ only spaces" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Line with only spaces"
        echo "  ✗ only spaces" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Tabs
    echo -e "\t\t\t\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "Line with only tabs"
        echo "  ✓ only tabs" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Line with only tabs"
        echo "  ✗ only tabs" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Very long command line
    local long_cmd="echo "$(printf 'A%.0s' {1..500})
    run_and_compare "$long_cmd" "Very long command (500 chars)"

    # 2000 character command
    local very_long_cmd="echo "$(printf 'B%.0s' {1..2000})
    run_and_compare "$very_long_cmd" "Extremely long command (2000 chars)"

    # Many spaces between arguments
    run_and_compare "echo hello                    world" "Many spaces between args"
    run_and_compare "echo                hello" "Spaces before arg"
    run_and_compare "echo hello                " "Spaces after arg"

    # Nonexistent command
    echo -e "nonexistent_cmd_xyz_123\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "Nonexistent command handling"
        echo "  ✓ nonexistent command" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_warn "Nonexistent command - shell may have crashed"
        echo "  ? nonexistent command" >> "$REPORT_FILE"
        ((TEST_WARNINGS++))
    fi
    ((TESTS_TOTAL++))

    # Special characters
    run_and_compare "echo '!@#$%^&*()'" "Special characters"
    run_and_compare "echo '{}[]<>?/\\|'" "More special characters"
    run_and_compare "echo '~\`!@#\$%^&*()_+-='" "All special chars"

    # Null bytes (should handle gracefully)
    run_and_compare "echo test" "Normal after special tests"

    echo "" >> "$REPORT_FILE"
}

test_builtins_comprehensive() {
    print_section "TEST 10: Built-in Commands - Comprehensive"
    echo "Test 10: Built-in Commands Comprehensive" >> "$REPORT_FILE"

    print_test_header "Testing built-in commands..."

    # CD tests
    local cd_tests=(
        "cd /tmp\npwd"
        "cd ..\npwd"
        "cd .\npwd"
        "cd ~\npwd"
        "cd\npwd"
        "cd /\npwd"
        "cd /usr\npwd"
    )

    for cd_test in "${cd_tests[@]}"; do
        echo -e "$cd_test\nexit" > "$TMP_DIR/test.txt"
        timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"

        if [ -s "$TMP_DIR/result.txt" ]; then
            print_pass "cd test"
            echo "  ✓ cd test" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_warn "cd test - uncertain"
            echo "  ? cd test" >> "$REPORT_FILE"
            ((TEST_WARNINGS++))
        fi
        ((TESTS_TOTAL++))
    done

    # Export tests
    local export_tests=(
        "export VAR1=value1\necho \$VAR1"
        "export VAR2='value with spaces'\necho \$VAR2"
        "export VAR3=\"value with spaces\"\necho \$VAR3"
        "export VAR4=\necho \$VAR4"
        "export VAR5=test\nexport VAR6=\$VAR5\necho \$VAR6"
    )

    for export_test in "${export_tests[@]}"; do
        echo -e "$export_test\nexit" > "$TMP_DIR/test.txt"
        timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"

        if [ -s "$TMP_DIR/result.txt" ]; then
            print_pass "export test"
            echo "  ✓ export test" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_warn "export test - uncertain"
            echo "  ? export test" >> "$REPORT_FILE"
            ((TEST_WARNINGS++))
        fi
        ((TESTS_TOTAL++))
    done

    # Unset test
    echo -e "export VAR=test\nunset VAR\necho \$VAR\nexit" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "unset command"
        echo "  ✓ unset" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_warn "unset command - uncertain"
        echo "  ? unset" >> "$REPORT_FILE"
        ((TEST_WARNINGS++))
    fi
    ((TESTS_TOTAL++))

    # Exit tests
    echo -e "exit\n" > "$TMP_DIR/test.txt"
    if timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"; then
        print_pass "exit command"
        echo "  ✓ exit" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "exit command"
        FAILED_TESTS+=("exit command")
        FAILED_DETAILS+=("exit builtin failed")
        echo "  ✗ exit" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Exit with code
    echo -e "exit 42\n" > "$TMP_DIR/test.txt"
    bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"
    local exit_code=$?
    ((TESTS_TOTAL++))
    if [ $exit_code -eq 42 ]; then
        print_pass "exit with code 42"
        echo "  ✓ exit with code" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_warn "exit with code (got $exit_code instead of 42)"
        echo "  ? exit with code" >> "$REPORT_FILE"
        ((TEST_WARNINGS++))
    fi

    echo "" >> "$REPORT_FILE"
}

test_stress_load() {
    print_section "TEST 11: Stress & Load Testing"
    echo "Test 11: Stress & Load Testing" >> "$REPORT_FILE"

    print_test_header "Running stress tests..."

    # 100 commands
    print_test_subheader "Executing 100 sequential commands..."
    {
        for i in $(seq 1 100); do
            echo "echo test$i"
        done
        echo "exit"
    } > "$TMP_DIR/load_100.txt"

    local time_ms=$(measure_time_ms "$MINISHELL" "$TMP_DIR/load_100.txt")
    local time_bash=$(measure_time_ms "bash" "$TMP_DIR/load_100.txt")

    if [ $? -eq 0 ]; then
        echo ""
        draw_table_header
        draw_table_row "100 commands" "$time_ms" "$time_bash"
        draw_table_footer
        echo "  100 commands: minishell=${time_ms}ms, bash=${time_bash}ms" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "100 commands test - TIMEOUT or CRASH"
        FAILED_TESTS+=("100 commands stress test")
        FAILED_DETAILS+=("Failed to execute 100 sequential commands")
        echo "  ✗ 100 commands test" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # 500 commands
    print_test_subheader "Executing 500 sequential commands..."
    {
        for i in $(seq 1 500); do
            echo "echo test$i"
        done
        echo "exit"
    } > "$TMP_DIR/load_500.txt"

    time_ms=$(measure_time_ms "$MINISHELL" "$TMP_DIR/load_500.txt")
    time_bash=$(measure_time_ms "bash" "$TMP_DIR/load_500.txt")

    if [ $? -eq 0 ]; then
        echo ""
        draw_table_header
        draw_table_row "500 commands" "$time_ms" "$time_bash"
        draw_table_footer
        echo "  500 commands: minishell=${time_ms}ms, bash=${time_bash}ms" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "500 commands test - TIMEOUT or CRASH"
        FAILED_TESTS+=("500 commands stress test")
        FAILED_DETAILS+=("Failed to execute 500 sequential commands")
        echo "  ✗ 500 commands test" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    # Large file handling
    print_test_subheader "Testing large file handling (10000 lines)..."
    seq 1 10000 > "$TMP_DIR/large_file.txt"

    echo -e "cat $TMP_DIR/large_file.txt | grep 5000\nexit" > "$TMP_DIR/test.txt"
    time_ms=$(measure_time_ms "$MINISHELL" "$TMP_DIR/test.txt")
    time_bash=$(measure_time_ms "bash" "$TMP_DIR/test.txt")

    if [ $? -eq 0 ]; then
        echo ""
        draw_table_header
        draw_table_row "Large file (10k lines)" "$time_ms" "$time_bash"
        draw_table_footer
        echo "  Large file: minishell=${time_ms}ms, bash=${time_bash}ms" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Large file test - TIMEOUT or CRASH"
        FAILED_TESTS+=("Large file (10k lines)")
        FAILED_DETAILS+=("Failed to process large file")
        echo "  ✗ large file test" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi
    ((TESTS_TOTAL++))

    echo "" >> "$REPORT_FILE"
}

test_memory_usage() {
    print_section "TEST 12: Memory Usage Analysis"
    echo "Test 12: Memory Usage" >> "$REPORT_FILE"

    print_test_header "Measuring memory consumption..."

    {
        for i in $(seq 1 30); do
            echo "echo test$i"
        done
        echo "sleep 1"
        echo "exit"
    } > "$TMP_DIR/memory_test.txt"

    cat "$TMP_DIR/memory_test.txt" | $MINISHELL > /dev/null 2>&1 &
    local pid=$!

    sleep 0.5

    if ps -p $pid > /dev/null 2>&1; then
        local mem_kb=$(ps -o rss= -p $pid 2>/dev/null | tr -d ' ')

        if [ -n "$mem_kb" ] && [ "$mem_kb" -gt 0 ]; then
            local mem_mb=$(echo "scale=2; $mem_kb / 1024" | bc)

            echo ""
            echo -e "${CYAN}╔════════════════════════════════════╗${RESET}"
            echo -e "${CYAN}║${RESET}${BOLD}     Memory Usage Statistics     ${RESET}${CYAN}║${RESET}"
            echo -e "${CYAN}╠════════════════════════════════════╣${RESET}"
            printf "${CYAN}║${RESET} RSS Memory:  ${YELLOW}%18s MB${RESET} ${CYAN}║${RESET}\n" "$mem_mb"
            printf "${CYAN}║${RESET} RSS Memory:  ${YELLOW}%18s KB${RESET} ${CYAN}║${RESET}\n" "$mem_kb"
            echo -e "${CYAN}╚════════════════════════════════════╝${RESET}"

            echo "  Memory: ${mem_mb} MB (${mem_kb} KB)" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_warn "Could not measure memory"
            echo "  ? Memory measurement failed" >> "$REPORT_FILE"
            ((TEST_WARNINGS++))
        fi

        wait $pid 2>/dev/null || true
    else
        print_warn "Process finished too quickly"
        echo "  ? Process too fast to measure" >> "$REPORT_FILE"
        ((TEST_WARNINGS++))
    fi
    ((TESTS_TOTAL++))

    echo "" >> "$REPORT_FILE"
}

test_complex_scenarios() {
    print_section "TEST 13: Complex Real-World Scenarios"
    echo "Test 13: Complex Scenarios" >> "$REPORT_FILE"

    print_test_header "Testing complex command combinations..."

    # Create test files
    echo "apple" > "$TMP_DIR/fruits.txt"
    echo "banana" >> "$TMP_DIR/fruits.txt"
    echo "cherry" >> "$TMP_DIR/fruits.txt"
    echo "date" >> "$TMP_DIR/fruits.txt"

    local complex_tests=(
        "cat $TMP_DIR/fruits.txt | grep a | wc -l"
        "echo test | cat | cat | cat | wc -l"
        "ls | grep bench | cat"
        "echo \$HOME | cat"
        "cat $TMP_DIR/fruits.txt | grep -v banana | wc -l"
        "ls -la | head -10 | tail -5"
    )

    echo ""
    draw_table_header

    for test_cmd in "${complex_tests[@]}"; do
        echo -e "$test_cmd\nexit" > "$TMP_DIR/test.txt"
        local time_ms=$(measure_time_ms "$MINISHELL" "$TMP_DIR/test.txt" 2>/dev/null || echo "0")
        local time_bash=$(measure_time_ms "bash" "$TMP_DIR/test.txt" 2>/dev/null || echo "1")

        local test_name="${test_cmd:0:34}"
        draw_table_row "$test_name" "$time_ms" "$time_bash"

        echo "$test_cmd: minishell=${time_ms}ms, bash=${time_bash}ms" >> "$REPORT_FILE"
    done

    draw_table_footer

    echo "" >> "$REPORT_FILE"
}

test_exit_codes() {
    print_section "TEST 14: Exit Code Verification - Ultra Strict"
    echo "Test 14: Exit Code Verification" >> "$REPORT_FILE"

    print_test_header "Testing exit codes match bash exactly..."

    local exit_code_tests=(
        "true"
        "false"
        "/bin/ls /nonexistent 2>/dev/null"
        "cd /nonexistent_directory 2>/dev/null"
        "export TEST_VAR=value && echo \$TEST_VAR"
        "unset PATH"
        "echo test && true"
        "echo test && false"
        "false || true"
        "true && false"
        "exit 42"
        "exit 0"
        "exit 1"
        "exit 127"
        "exit 255"
    )

    echo ""

    for test_cmd in "${exit_code_tests[@]}"; do
        ((TESTS_TOTAL++))

        # Run in minishell and capture exit code
        echo -e "$test_cmd\nexit" > "$TMP_DIR/input.txt"
        timeout 10 bash -c "cat '$TMP_DIR/input.txt' | $MINISHELL > /dev/null 2>&1"
        local ms_exit=$?

        # Run in bash and capture exit code
        bash --norc --noprofile -c "$test_cmd" > /dev/null 2>&1
        local bash_exit=$?

        local test_name="exit code: $test_cmd"

        if [ $ms_exit -eq $bash_exit ]; then
            print_pass "$test_name (exit=$bash_exit)"
            echo "  ✓ $test_name (exit=$bash_exit)" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "$test_name - Expected exit=$bash_exit, Got exit=$ms_exit"
            FAILED_TESTS+=("$test_name")
            FAILED_DETAILS+=("Expected exit code: $bash_exit | Got: $ms_exit")
            echo "  ✗ $test_name - EXIT CODE MISMATCH" >> "$REPORT_FILE"
            echo "    Expected: $bash_exit" >> "$REPORT_FILE"
            echo "    Got:      $ms_exit" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_stderr_stdout_separation() {
    print_section "TEST 15: Stdout vs Stderr Separation - Ultra Strict"
    echo "Test 15: Stdout vs Stderr Separation" >> "$REPORT_FILE"

    print_test_header "Testing output stream separation..."

    local stream_tests=(
        "echo test 1>&2"
        "echo stdout; echo stderr 1>&2"
        "ls /nonexistent 2>&1"
        "ls /nonexistent 2>/dev/null"
        "echo out; ls /nonexistent 2>&1"
        "echo test > /dev/stdout"
        "echo error > /dev/stderr"
        "cat /nonexistent 2>&1 | cat"
        "echo test | cat 2>&1"
    )

    echo ""

    for test_cmd in "${stream_tests[@]}"; do
        ((TESTS_TOTAL++))

        # Run in minishell
        echo -e "$test_cmd\nexit" > "$TMP_DIR/input.txt"
        timeout 10 bash -c "cat '$TMP_DIR/input.txt' | $MINISHELL 2>&1" > "$TMP_DIR/ms_out.txt" 2>&1
        grep -v "^minishell" "$TMP_DIR/ms_out.txt" | grep -v "^\$" | grep -v "^>" > "$TMP_DIR/ms_clean.txt" 2>/dev/null || touch "$TMP_DIR/ms_clean.txt"

        # Run in bash
        bash --norc --noprofile -c "$test_cmd" > "$TMP_DIR/bash_out.txt" 2>&1

        local test_name="stream: $test_cmd"

        if diff -q "$TMP_DIR/ms_clean.txt" "$TMP_DIR/bash_out.txt" > /dev/null 2>&1; then
            print_pass "$test_name"
            echo "  ✓ $test_name" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            local expected=$(cat "$TMP_DIR/bash_out.txt" 2>/dev/null | head -3 || echo "(empty)")
            local got=$(cat "$TMP_DIR/ms_clean.txt" 2>/dev/null | head -3 || echo "(empty)")

            print_fail "$test_name - STREAM OUTPUT MISMATCH"
            FAILED_TESTS+=("$test_name")
            FAILED_DETAILS+=("Expected: '$expected' | Got: '$got'")
            echo "  ✗ $test_name - OUTPUT MISMATCH" >> "$REPORT_FILE"
            echo "    Expected: $expected" >> "$REPORT_FILE"
            echo "    Got:      $got" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_signal_handling() {
    print_section "TEST 16: Signal Handling - Ultra Strict"
    echo "Test 16: Signal Handling" >> "$REPORT_FILE"

    print_test_header "Testing signal handling behavior..."

    echo ""
    echo -e "${YELLOW}Note: Signal tests check Ctrl+C (SIGINT) handling${RESET}"
    echo ""

    # Test 1: Ctrl+C during command execution
    ((TESTS_TOTAL++))
    echo -e "sleep 1\nexit" > "$TMP_DIR/input.txt"
    timeout 2 bash -c "(sleep 0.5 && kill -INT \$(pgrep -f 'minishell' | head -1)) & cat '$TMP_DIR/input.txt' | $MINISHELL > /dev/null 2>&1" 2>/dev/null
    local ms_sig_result=$?

    if [ $ms_sig_result -ne 0 ] || [ $ms_sig_result -eq 130 ]; then
        print_pass "SIGINT during command execution"
        echo "  ✓ SIGINT during command execution" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "SIGINT during command execution - No interrupt detected"
        FAILED_TESTS+=("SIGINT handling")
        FAILED_DETAILS+=("SIGINT should interrupt command execution")
        echo "  ✗ SIGINT handling - No interrupt detected" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test 2: Multiple Ctrl+C presses
    ((TESTS_TOTAL++))
    print_pass "Multiple SIGINT handling ${DIM}(interactive test)${RESET}"
    echo "  ✓ Multiple SIGINT handling (requires manual testing)" >> "$REPORT_FILE"
    ((TESTS_PASSED++))

    # Test 3: SIGINT with pipes
    ((TESTS_TOTAL++))
    echo -e "cat | sleep 1\nexit" > "$TMP_DIR/input.txt"
    timeout 2 bash -c "cat '$TMP_DIR/input.txt' | $MINISHELL > /dev/null 2>&1" 2>/dev/null
    local pipe_sig_result=$?

    if [ $pipe_sig_result -eq 124 ] || [ $pipe_sig_result -eq 130 ] || [ $pipe_sig_result -eq 0 ]; then
        print_pass "SIGINT with pipes"
        echo "  ✓ SIGINT with pipes" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "SIGINT with pipes - Unexpected behavior"
        FAILED_TESTS+=("SIGINT with pipes")
        FAILED_DETAILS+=("Signal handling in pipes may be incorrect")
        echo "  ✗ SIGINT with pipes - Unexpected behavior" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_wildcards_and_special() {
    print_section "TEST 17: Wildcards and Special Characters - Ultra Strict"
    echo "Test 17: Wildcards and Special Characters" >> "$REPORT_FILE"

    print_test_header "Testing wildcard expansion and special characters..."

    # Create test files for wildcard matching
    mkdir -p "$TMP_DIR/wildtest"
    touch "$TMP_DIR/wildtest/file1.txt"
    touch "$TMP_DIR/wildtest/file2.txt"
    touch "$TMP_DIR/wildtest/file3.md"
    touch "$TMP_DIR/wildtest/test.sh"

    local wildcard_tests=(
        "echo $TMP_DIR/wildtest/*.txt"
        "echo $TMP_DIR/wildtest/*"
        "echo $TMP_DIR/wildtest/*.md"
        "ls $TMP_DIR/wildtest/*.txt 2>&1 | wc -l"
        "echo *"
        "echo *.sh"
        "echo ???"
        "echo '*.txt'"
        "echo \"*.txt\""
        "echo \$HOME/*.txt 2>&1"
    )

    echo ""

    for test_cmd in "${wildcard_tests[@]}"; do
        run_and_compare "$test_cmd" "wildcard: $test_cmd"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_heredoc_comprehensive() {
    print_section "TEST 18: Heredoc - Comprehensive Testing"
    echo "Test 18: Heredoc Comprehensive" >> "$REPORT_FILE"

    print_test_header "Testing heredoc with various scenarios..."

    # Basic heredoc
    cat > "$TMP_DIR/heredoc_test1.txt" << 'TESTSCRIPT'
cat << EOF
line 1
line 2
line 3
EOF
exit
TESTSCRIPT

    timeout 10 bash -c "cat '$TMP_DIR/heredoc_test1.txt' | $MINISHELL > $TMP_DIR/ms_heredoc1.txt 2>&1"
    echo -e "line 1\nline 2\nline 3" > "$TMP_DIR/expected_heredoc1.txt"

    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/ms_heredoc1.txt" | grep -v "^\$" > "$TMP_DIR/ms_clean.txt"
    if diff -q "$TMP_DIR/ms_clean.txt" "$TMP_DIR/expected_heredoc1.txt" > /dev/null 2>&1; then
        print_pass "Basic heredoc"
        echo "  ✓ basic heredoc" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Basic heredoc - Output mismatch"
        FAILED_TESTS+=("Basic heredoc")
        FAILED_DETAILS+=("Heredoc output doesn't match expected")
        echo "  ✗ basic heredoc" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Heredoc with variable expansion
    cat > "$TMP_DIR/heredoc_test2.txt" << 'TESTSCRIPT'
cat << EOF
HOME is $HOME
USER is $USER
EOF
exit
TESTSCRIPT

    timeout 10 bash -c "cat '$TMP_DIR/heredoc_test2.txt' | $MINISHELL > $TMP_DIR/ms_heredoc2.txt 2>&1"
    timeout 10 bash -c "cat '$TMP_DIR/heredoc_test2.txt' | bash --norc --noprofile > $TMP_DIR/bash_heredoc2.txt 2>&1"

    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/ms_heredoc2.txt" | grep -v "^\$" > "$TMP_DIR/ms_clean2.txt"
    if diff -q "$TMP_DIR/ms_clean2.txt" "$TMP_DIR/bash_heredoc2.txt" > /dev/null 2>&1; then
        print_pass "Heredoc with variable expansion"
        echo "  ✓ heredoc with variables" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Heredoc with variable expansion - Expansion issue"
        FAILED_TESTS+=("Heredoc with variables")
        FAILED_DETAILS+=("Variable expansion in heredoc failed")
        echo "  ✗ heredoc with variables" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Heredoc with quotes
    cat > "$TMP_DIR/heredoc_test3.txt" << 'TESTSCRIPT'
cat << 'EOF'
$HOME should not expand
'single quotes'
"double quotes"
EOF
exit
TESTSCRIPT

    timeout 10 bash -c "cat '$TMP_DIR/heredoc_test3.txt' | $MINISHELL > $TMP_DIR/ms_heredoc3.txt 2>&1"

    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/ms_heredoc3.txt" | grep -v "^\$" > "$TMP_DIR/ms_clean3.txt"
    if grep -q '\$HOME should not expand' "$TMP_DIR/ms_clean3.txt"; then
        print_pass "Heredoc with quoted delimiter (no expansion)"
        echo "  ✓ heredoc quoted delimiter" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Heredoc with quoted delimiter - Expansion occurred"
        FAILED_TESTS+=("Heredoc quoted delimiter")
        FAILED_DETAILS+=("Variables should not expand with quoted delimiter")
        echo "  ✗ heredoc quoted delimiter" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Multiple heredocs
    cat > "$TMP_DIR/heredoc_test4.txt" << 'TESTSCRIPT'
cat << EOF
first heredoc
EOF
cat << EOF
second heredoc
EOF
exit
TESTSCRIPT

    timeout 10 bash -c "cat '$TMP_DIR/heredoc_test4.txt' | $MINISHELL > $TMP_DIR/ms_heredoc4.txt 2>&1"

    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/ms_heredoc4.txt" | grep -v "^\$" > "$TMP_DIR/ms_clean4.txt"
    if grep -q "first heredoc" "$TMP_DIR/ms_clean4.txt" && grep -q "second heredoc" "$TMP_DIR/ms_clean4.txt"; then
        print_pass "Multiple heredocs in sequence"
        echo "  ✓ multiple heredocs" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Multiple heredocs - Not all heredocs processed"
        FAILED_TESTS+=("Multiple heredocs")
        FAILED_DETAILS+=("One or more heredocs failed")
        echo "  ✗ multiple heredocs" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Heredoc with special characters
    cat > "$TMP_DIR/heredoc_test5.txt" << 'TESTSCRIPT'
cat << EOF
special chars: !@#$%^&*()
brackets: []{}()<>
quotes: '"
EOF
exit
TESTSCRIPT

    timeout 10 bash -c "cat '$TMP_DIR/heredoc_test5.txt' | $MINISHELL > $TMP_DIR/ms_heredoc5.txt 2>&1"

    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/ms_heredoc5.txt" | grep -v "^\$" > "$TMP_DIR/ms_clean5.txt"
    if grep -q "special chars" "$TMP_DIR/ms_clean5.txt"; then
        print_pass "Heredoc with special characters"
        echo "  ✓ heredoc special chars" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Heredoc with special characters"
        FAILED_TESTS+=("Heredoc special chars")
        FAILED_DETAILS+=("Special characters not handled properly")
        echo "  ✗ heredoc special chars" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_exit_codes_ultra_strict() {
    print_section "TEST 19: Exit Codes - Ultra Strict Validation"
    echo "Test 19: Exit Codes Ultra Strict" >> "$REPORT_FILE"

    print_test_header "Testing exit codes for all commands and builtins..."

    # Test exit code 0 (success)
    echo -e "echo test\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep -v "^test" > "$TMP_DIR/clean.txt"
    if grep -q "^0$" "$TMP_DIR/clean.txt"; then
        print_pass "Exit code 0 after successful echo"
        echo "  ✓ exit code 0" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Exit code 0 - Expected 0, got: $(cat $TMP_DIR/clean.txt)"
        FAILED_TESTS+=("Exit code 0")
        FAILED_DETAILS+=("Exit code should be 0 after successful command")
        echo "  ✗ exit code 0" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test exit code after failed command
    echo -e "/bin/false\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | tail -1 > "$TMP_DIR/clean.txt"
    if grep -q "^1$" "$TMP_DIR/clean.txt"; then
        print_pass "Exit code 1 after /bin/false"
        echo "  ✓ exit code 1" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Exit code 1 - Expected 1, got: $(cat $TMP_DIR/clean.txt)"
        FAILED_TESTS+=("Exit code 1")
        FAILED_DETAILS+=("Exit code should be 1 after /bin/false")
        echo "  ✗ exit code 1" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test exit code 127 (command not found)
    echo -e "nonexistentcommand123456789\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep "^127$" > "$TMP_DIR/clean.txt"
    if [ -s "$TMP_DIR/clean.txt" ]; then
        print_pass "Exit code 127 for command not found"
        echo "  ✓ exit code 127" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Exit code 127 - Command not found should return 127"
        FAILED_TESTS+=("Exit code 127")
        FAILED_DETAILS+=("Command not found should set exit code to 127")
        echo "  ✗ exit code 127" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test exit code with cd builtin (success)
    echo -e "cd /tmp\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep "^0$" > "$TMP_DIR/clean.txt"
    if [ -s "$TMP_DIR/clean.txt" ]; then
        print_pass "Exit code 0 for successful cd"
        echo "  ✓ cd exit code 0" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Exit code for cd - Should be 0 after successful cd"
        FAILED_TESTS+=("cd exit code")
        FAILED_DETAILS+=("cd to valid directory should return 0")
        echo "  ✗ cd exit code 0" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test exit code with cd builtin (failure)
    echo -e "cd /nonexistent_dir_12345\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep -E "^[1-9][0-9]*$" > "$TMP_DIR/clean.txt"
    if [ -s "$TMP_DIR/clean.txt" ]; then
        print_pass "Exit code non-zero for failed cd"
        echo "  ✓ cd exit code non-zero" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Exit code for failed cd - Should be non-zero"
        FAILED_TESTS+=("cd failed exit code")
        FAILED_DETAILS+=("cd to invalid directory should return non-zero")
        echo "  ✗ cd exit code non-zero" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test exit with explicit code
    echo -e "exit 42" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    local exit_code=$?
    ((TESTS_TOTAL++))
    if [ $exit_code -eq 42 ]; then
        print_pass "Exit with code 42"
        echo "  ✓ exit 42" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Exit code 42 - Expected 42, got: $exit_code"
        FAILED_TESTS+=("Exit 42")
        FAILED_DETAILS+=("exit 42 should exit with code 42")
        echo "  ✗ exit 42" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test exit code propagation through pipe
    echo -e "/bin/false | echo test\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | bash --norc --noprofile > $TMP_DIR/bash_result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | tail -1 > "$TMP_DIR/ms_exit.txt"
    tail -1 "$TMP_DIR/bash_result.txt" > "$TMP_DIR/bash_exit.txt"
    if diff -q "$TMP_DIR/ms_exit.txt" "$TMP_DIR/bash_exit.txt" > /dev/null 2>&1; then
        print_pass "Exit code propagation through pipe"
        echo "  ✓ pipe exit code" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Pipe exit code - Minishell: $(cat $TMP_DIR/ms_exit.txt) vs Bash: $(cat $TMP_DIR/bash_exit.txt)"
        FAILED_TESTS+=("Pipe exit code")
        FAILED_DETAILS+=("Exit code through pipe doesn't match bash")
        echo "  ✗ pipe exit code" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test export exit code
    echo -e "export TEST_VAR=value\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep "^0$" > "$TMP_DIR/clean.txt"
    if [ -s "$TMP_DIR/clean.txt" ]; then
        print_pass "Exit code 0 for export"
        echo "  ✓ export exit code" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Export exit code - Should be 0"
        FAILED_TESTS+=("export exit code")
        FAILED_DETAILS+=("export should return 0 on success")
        echo "  ✗ export exit code" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test unset exit code
    echo -e "unset PATH\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep "^0$" > "$TMP_DIR/clean.txt"
    if [ -s "$TMP_DIR/clean.txt" ]; then
        print_pass "Exit code 0 for unset"
        echo "  ✓ unset exit code" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Unset exit code - Should be 0"
        FAILED_TESTS+=("unset exit code")
        FAILED_DETAILS+=("unset should return 0")
        echo "  ✗ unset exit code" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    # Test env exit code
    echo -e "env\necho \$?\nexit" > "$TMP_DIR/test.txt"
    timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
    ((TESTS_TOTAL++))
    grep -v "^minishell" "$TMP_DIR/result.txt" | grep -v "^\$" | grep "^0$" > "$TMP_DIR/clean.txt"
    if [ -s "$TMP_DIR/clean.txt" ]; then
        print_pass "Exit code 0 for env"
        echo "  ✓ env exit code" >> "$REPORT_FILE"
        ((TESTS_PASSED++))
    else
        print_fail "Env exit code - Should be 0"
        FAILED_TESTS+=("env exit code")
        FAILED_DETAILS+=("env should return 0")
        echo "  ✗ env exit code" >> "$REPORT_FILE"
        ((TESTS_FAILED++))
    fi

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_variable_expansion_advanced() {
    print_section "TEST 20: Variable Expansion - Advanced Edge Cases"
    echo "Test 20: Variable Expansion Advanced" >> "$REPORT_FILE"

    print_test_header "Testing advanced variable expansion scenarios..."

    # Variable expansion edge cases
    local expansion_tests=(
        "echo \$"
        "echo \$\$"
        "echo \$123"
        "echo \${HOME}"
        "echo \$HOME\$PATH"
        "echo \$HOME/\$USER"
        "echo prefix\$HOMEsuffix"
        "echo \$NONEXISTENT\$HOME"
        "echo \"\$HOME\""
        "echo '\$HOME'"
        "echo \$HOME'\$PATH'"
        "echo \"\$HOME'\$PATH'\""
        "echo \$?"
        "echo \$? \$? \$?"
        "/bin/false; echo \$?"
        "/bin/true; echo \$?"
        "echo test\$\$test"
        "echo \\\$HOME"
        "echo \"\\\$HOME\""
        "echo test > /dev/null; echo \$?"
    )

    for test_cmd in "${expansion_tests[@]}"; do
        run_and_compare "$test_cmd" "var expand: ${test_cmd:0:30}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_quotes_edge_cases() {
    print_section "TEST 21: Quote Handling - Edge Cases"
    echo "Test 21: Quote Edge Cases" >> "$REPORT_FILE"

    print_test_header "Testing quote edge cases and complex mixing..."

    local quote_tests=(
        "echo \"'hello'\""
        "echo '\"hello\"'"
        "echo \"'\"hello\"'\""
        "echo '\"'hello'\"'"
        "echo \"test\\\$HOME\""
        "echo 'test\\\$HOME'"
        "echo \"test'with'quotes\""
        "echo 'test\"with\"quotes'"
        "echo \"multiple  spaces   preserved\""
        "echo 'multiple  spaces   preserved'"
        "echo \"tab\t\there\""
        "echo 'tab\t\there'"
        "echo \"\""
        "echo ''"
        "echo \"\" \"\" \"\""
        "echo '' '' ''"
        "echo \"\\\"escaped quotes\\\"\""
        "echo 'can\\'t escape in single'"
        "echo \"mix 'single' in double\""
        "echo 'mix \"double\" in single'"
        "echo \"test\ntest\""
        "echo 'test\ntest'"
        "echo \"'\$HOME'\""
        "echo '\"\$HOME\"'"
        "echo \"\$HOME\"\$USER"
        "echo '\$HOME'\$USER"
    )

    for test_cmd in "${quote_tests[@]}"; do
        run_and_compare "$test_cmd" "quote: ${test_cmd:0:30}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_pipes_extreme() {
    print_section "TEST 22: Pipes - Extreme Multi-Pipe Testing"
    echo "Test 22: Pipes Extreme" >> "$REPORT_FILE"

    print_test_header "Testing extreme pipe scenarios (5-10 pipes)..."

    # Create test data
    seq 1 1000 > "$TMP_DIR/numbers.txt"

    local extreme_pipe_tests=(
        "echo test | cat | cat | cat | cat | cat"
        "echo test | cat | cat | cat | cat | cat | cat"
        "echo test | cat | cat | cat | cat | cat | cat | cat"
        "echo hello world | cat | cat | cat | cat | cat | cat | cat | cat"
        "echo test | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/numbers.txt | head -100 | tail -50 | head -25 | tail -10"
        "cat $TMP_DIR/numbers.txt | grep 5 | grep 0 | wc -l"
        "echo a b c d e | cat | cat | cat | grep b | cat"
        "cat $TMP_DIR/numbers.txt | head -500 | tail -250 | grep 2 | head -10"
        "echo test | cat | grep test | cat | cat | cat"
    )

    for test_cmd in "${extreme_pipe_tests[@]}"; do
        run_and_compare "$test_cmd" "extreme pipe: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_redirections_advanced() {
    print_section "TEST 23: Redirections - Advanced Combinations"
    echo "Test 23: Redirections Advanced" >> "$REPORT_FILE"

    print_test_header "Testing advanced redirection combinations..."

    # Multiple redirections
    echo "test content" > "$TMP_DIR/input1.txt"
    echo "more content" > "$TMP_DIR/input2.txt"

    local redir_tests=(
        "cat < $TMP_DIR/input1.txt > $TMP_DIR/output1.txt"
        "cat < $TMP_DIR/input1.txt < $TMP_DIR/input2.txt"
        "echo test > $TMP_DIR/out.txt > $TMP_DIR/out2.txt"
        "echo line1 > $TMP_DIR/multi.txt; echo line2 >> $TMP_DIR/multi.txt"
        "cat < $TMP_DIR/input1.txt >> $TMP_DIR/append.txt"
        "echo test > $TMP_DIR/a.txt; cat < $TMP_DIR/a.txt"
        "echo test > $TMP_DIR/b.txt; echo test2 >> $TMP_DIR/b.txt; cat $TMP_DIR/b.txt"
    )

    for test_cmd in "${redir_tests[@]}"; do
        run_and_compare "$test_cmd" "redir advanced: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_pipes_and_redirections_combined() {
    print_section "TEST 24: Pipes + Redirections - Combined"
    echo "Test 24: Pipes + Redirections Combined" >> "$REPORT_FILE"

    print_test_header "Testing combinations of pipes and redirections..."

    echo "test data" > "$TMP_DIR/data.txt"

    local combined_tests=(
        "cat < $TMP_DIR/data.txt | cat"
        "echo test | cat > $TMP_DIR/pipe_out.txt"
        "cat $TMP_DIR/data.txt | cat | cat > $TMP_DIR/multi_pipe_out.txt"
        "echo test | cat | cat | cat > $TMP_DIR/final.txt"
        "cat < $TMP_DIR/data.txt | cat | cat > $TMP_DIR/result.txt"
        "echo line1 > $TMP_DIR/temp.txt; cat $TMP_DIR/temp.txt | cat"
        "echo test | cat | cat > $TMP_DIR/out.txt; cat $TMP_DIR/out.txt"
    )

    for test_cmd in "${combined_tests[@]}"; do
        run_and_compare "$test_cmd" "pipe+redir: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_builtins_edge_cases() {
    print_section "TEST 25: Builtins - Edge Cases"
    echo "Test 25: Builtins Edge Cases" >> "$REPORT_FILE"

    print_test_header "Testing builtin commands with edge cases..."

    # pwd edge cases
    run_and_compare "pwd" "pwd: basic"
    run_and_compare "pwd; cd /tmp; pwd" "pwd: after cd"
    run_and_compare "pwd; pwd; pwd" "pwd: multiple calls"

    # cd edge cases
    run_and_compare "cd" "cd: no argument (HOME)"
    run_and_compare "cd /" "cd: to root"
    run_and_compare "cd /tmp; pwd" "cd: verify with pwd"
    run_and_compare "cd /nonexistent" "cd: to nonexistent"
    run_and_compare "cd .." "cd: parent directory"
    run_and_compare "cd .; pwd" "cd: current directory"
    run_and_compare "cd -" "cd: previous directory"

    # echo edge cases (already covered but adding more)
    run_and_compare "echo" "echo: no arguments"
    run_and_compare "echo -n" "echo: -n only"
    run_and_compare "echo -n -n -n" "echo: multiple -n"
    run_and_compare "echo -nnn test" "echo: -nnn variant"

    # env edge cases
    run_and_compare "env" "env: basic"
    run_and_compare "env | grep PATH" "env: with pipe"

    # export edge cases
    run_and_compare "export" "export: no arguments"
    run_and_compare "export TEST=value" "export: new variable"
    run_and_compare "export TEST=value; echo \$TEST" "export: verify"
    run_and_compare "export EMPTY=" "export: empty value"
    run_and_compare "export SPACE=' '" "export: space value"
    run_and_compare "export MULTI='a b c'" "export: multiple words"

    # unset edge cases
    run_and_compare "unset" "unset: no arguments"
    run_and_compare "unset NONEXISTENT" "unset: nonexistent var"
    run_and_compare "export TEST=1; unset TEST; echo \$TEST" "unset: verify removal"

    # exit edge cases
    run_and_compare "exit 0" "exit: with 0"
    run_and_compare "exit 1" "exit: with 1"
    run_and_compare "exit 255" "exit: with 255"
    run_and_compare "exit 256" "exit: overflow 256"
    run_and_compare "exit -1" "exit: negative"
    run_and_compare "exit abc" "exit: non-numeric"

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_command_not_found() {
    print_section "TEST 26: Command Not Found Handling"
    echo "Test 26: Command Not Found" >> "$REPORT_FILE"

    print_test_header "Testing command not found scenarios..."

    local not_found_tests=(
        "nonexistentcommand"
        "cmddoesnotexist123"
        "./nonexistent_binary"
        "/nonexistent/path/command"
        "abc123xyz789"
        "test_fake_cmd"
        ""
    )

    for test_cmd in "${not_found_tests[@]}"; do
        if [ -n "$test_cmd" ]; then
            echo -e "$test_cmd\necho \$?\nexit" > "$TMP_DIR/test.txt"
            timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > $TMP_DIR/result.txt 2>&1"
            ((TESTS_TOTAL++))

            if grep -q "command not found\|not found\|127" "$TMP_DIR/result.txt"; then
                print_pass "Command not found: $test_cmd"
                echo "  ✓ not found: $test_cmd" >> "$REPORT_FILE"
                ((TESTS_PASSED++))
            else
                print_fail "Command not found handling: $test_cmd"
                FAILED_TESTS+=("Not found: $test_cmd")
                FAILED_DETAILS+=("Should show 'command not found' error")
                echo "  ✗ not found: $test_cmd" >> "$REPORT_FILE"
                ((TESTS_FAILED++))
            fi
        fi
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_paths_with_spaces() {
    print_section "TEST 27: Paths with Spaces and Special Characters"
    echo "Test 27: Paths with Spaces" >> "$REPORT_FILE"

    print_test_header "Testing paths with spaces and special characters..."

    # Create test directories and files with spaces
    mkdir -p "$TMP_DIR/dir with spaces"
    echo "content" > "$TMP_DIR/dir with spaces/file.txt"
    mkdir -p "$TMP_DIR/dir-with-dash"
    echo "dash content" > "$TMP_DIR/dir-with-dash/file.txt"
    mkdir -p "$TMP_DIR/dir_with_underscore"
    echo "underscore" > "$TMP_DIR/dir_with_underscore/file.txt"

    local space_tests=(
        "echo '$TMP_DIR/dir with spaces/file.txt'"
        "cat '$TMP_DIR/dir with spaces/file.txt'"
        "ls '$TMP_DIR/dir with spaces'"
        "echo \"$TMP_DIR/dir with spaces/file.txt\""
        "cat $TMP_DIR/dir-with-dash/file.txt"
        "cat $TMP_DIR/dir_with_underscore/file.txt"
        "echo test > '$TMP_DIR/dir with spaces/output.txt'"
        "ls '$TMP_DIR/dir with spaces' | cat"
    )

    for test_cmd in "${space_tests[@]}"; do
        run_and_compare "$test_cmd" "path spaces: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_echo_ultra_extended() {
    print_section "TEST 28: Echo - Ultra Extended (50+ tests)"
    echo "Test 28: Echo Ultra Extended" >> "$REPORT_FILE"

    print_test_header "Testing echo with 50+ additional scenarios..."

    local echo_tests=(
        "echo -n -n -n -n test"
        "echo -nnnn test"
        "echo -n-n-n test"
        "echo -- test"
        "echo --- test"
        "echo -e 'test'"
        "echo -E 'test'"
        "echo -ne test"
        "echo -nE test"
        "echo test1 test2 test3 test4 test5 test6 test7 test8 test9 test10"
        "echo 'test1' 'test2' 'test3' 'test4' 'test5'"
        "echo \"test1\" \"test2\" \"test3\" \"test4\""
        "echo a'b'c\"d\"e"
        "echo 'a\"b'\"c'd\""
        "echo \$HOME\$USER\$PWD"
        "echo '\$HOME\$USER\$PWD'"
        "echo \"\$HOME\$USER\$PWD\""
        "echo test | cat | cat | cat"
        "echo -n test | cat"
        "echo test > /dev/null"
        "echo test 2> /dev/null"
        "echo test > /dev/null 2>&1"
        "echo -n > /dev/null"
        "echo '' '' '' '' ''"
        "echo \"\" \"\" \"\" \"\""
        "echo test     with     spaces"
        "echo 'test     with     spaces'"
        "echo \"test     with     spaces\""
        "echo test\$"
        "echo test\$\$"
        "echo \$\$\$"
        "echo test\\\$test"
        "echo 'test\\ntest'"
        "echo \"test\\ntest\""
        "echo 'test\\ttest'"
        "echo \"test\\ttest\""
        "echo test\\test"
        "echo test\\\\test"
        "echo 'test\\\\test'"
        "echo a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9"
        "echo !@#\$%^&*()_+-={}[]|:;'<>,.?/"
        "echo '!@#\$%^&*()_+-={}[]|:;\"<>,.?/'"
        "echo test && echo test2"
        "echo test || echo test2"
        "echo test; echo test2"
        "echo -n test; echo test2"
        "echo test | grep test | cat | cat"
        "echo -n -n test | cat | cat"
        "echo test test test test test"
        "echo 'test test test test test'"
    )

    for test_cmd in "${echo_tests[@]}"; do
        run_and_compare "$test_cmd" "echo ext: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_pipes_ultra() {
    print_section "TEST 29: Pipes - Ultra Comprehensive (50+ tests)"
    echo "Test 29: Pipes Ultra" >> "$REPORT_FILE"

    print_test_header "Testing pipes with 50+ scenarios..."

    seq 1 10000 > "$TMP_DIR/huge.txt"

    local pipe_tests=(
        "echo test | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/huge.txt | head -1000 | tail -500 | head -100 | tail -50"
        "echo a | cat | cat | cat | cat | cat | grep a"
        "echo test | cat | grep test | cat | grep test | cat"
        "echo 'a b c' | cat | cat | cat"
        "ls | cat | cat | cat | wc -l"
        "echo test | cat | cat > /dev/null"
        "echo test | cat | cat 2> /dev/null"
        "cat $TMP_DIR/huge.txt | grep 1 | wc -l"
        "cat $TMP_DIR/huge.txt | grep 2 | wc -l"
        "cat $TMP_DIR/huge.txt | grep 3 | wc -l"
        "echo a | grep a | grep a | grep a"
        "echo test | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "ls | head -5 | tail -3"
        "ls | head -10 | cat"
        "echo test | wc -l"
        "echo -n test | wc -l"
        "cat /dev/null | cat"
        "echo '' | cat"
        "echo | cat | cat"
        "echo test | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/huge.txt | head -5000 | tail -1000 | grep 4"
        "echo 1 | cat | cat | cat | cat | cat"
        "echo 2 | cat | cat | cat | cat | cat"
        "echo a b c | cat | grep b"
        "echo test test test | cat | cat"
        "ls -la | grep bench | cat"
        "ls | cat | cat | cat | cat | wc -l"
        "echo -n a | cat | cat"
        "echo -n | cat | cat"
        "cat $TMP_DIR/huge.txt | wc -l"
        "cat $TMP_DIR/huge.txt | head -1"
        "cat $TMP_DIR/huge.txt | tail -1"
        "echo 'pipe test' | cat | cat | cat | cat"
        "echo test | cat | cat | cat | cat | cat | cat | cat"
        "ls | cat | cat | cat | cat | cat | cat"
        "echo a | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/huge.txt | grep 5 | head -10"
        "cat $TMP_DIR/huge.txt | grep 6 | tail -10"
        "cat $TMP_DIR/huge.txt | head -100 | grep 7"
        "echo multiple words here | cat | cat | cat"
        "echo test1 test2 test3 | cat | grep test2"
        "ls | head -1 | cat | cat"
        "ls | tail -1 | cat | cat"
        "echo final | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/huge.txt | head -50 | tail -25 | head -10 | tail -5"
        "echo 'complex | pipe' | cat"
        "echo test | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/huge.txt | grep 8 | grep 8 | wc -l"
        "echo end | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat"
    )

    for test_cmd in "${pipe_tests[@]}"; do
        run_and_compare "$test_cmd" "pipe ultra: ${test_cmd:0:20}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_redirections_ultra() {
    print_section "TEST 30: Redirections - Ultra Complete (40+ tests)"
    echo "Test 30: Redirections Ultra" >> "$REPORT_FILE"

    print_test_header "Testing redirections with 40+ scenarios..."

    local redir_tests=(
        "echo test > $TMP_DIR/r1.txt; cat $TMP_DIR/r1.txt"
        "echo test >> $TMP_DIR/r2.txt; echo test2 >> $TMP_DIR/r2.txt; cat $TMP_DIR/r2.txt"
        "cat < /dev/null"
        "echo test > $TMP_DIR/r3.txt; cat < $TMP_DIR/r3.txt"
        "echo a > $TMP_DIR/r4.txt; echo b >> $TMP_DIR/r4.txt; cat $TMP_DIR/r4.txt"
        "echo test 2> $TMP_DIR/err.txt"
        "ls /nonexistent 2> $TMP_DIR/err2.txt"
        "echo test > $TMP_DIR/r5.txt 2>&1"
        "echo a > $TMP_DIR/r6.txt; echo b > $TMP_DIR/r6.txt; cat $TMP_DIR/r6.txt"
        "cat < /dev/null > $TMP_DIR/r7.txt"
        "echo test > /dev/null; echo \$?"
        "echo test >> /dev/null; echo \$?"
        "cat < /dev/null | cat"
        "echo test > $TMP_DIR/r8.txt; cat $TMP_DIR/r8.txt > $TMP_DIR/r9.txt; cat $TMP_DIR/r9.txt"
        "echo line1 > $TMP_DIR/r10.txt; echo line2 >> $TMP_DIR/r10.txt; echo line3 >> $TMP_DIR/r10.txt; wc -l < $TMP_DIR/r10.txt"
        "echo test > $TMP_DIR/r11.txt; cat $TMP_DIR/r11.txt | cat"
        "echo a > $TMP_DIR/r12.txt; cat $TMP_DIR/r12.txt | cat > $TMP_DIR/r13.txt"
        "echo test >> $TMP_DIR/r14.txt; cat $TMP_DIR/r14.txt"
        "cat < /dev/null > /dev/null"
        "echo test > $TMP_DIR/r15.txt 2> /dev/null"
        "ls > $TMP_DIR/r16.txt; cat $TMP_DIR/r16.txt | wc -l"
        "echo a > $TMP_DIR/r17.txt; echo b >> $TMP_DIR/r17.txt; echo c >> $TMP_DIR/r17.txt; cat $TMP_DIR/r17.txt"
        "echo test > $TMP_DIR/r18.txt; echo test2 > $TMP_DIR/r18.txt; cat $TMP_DIR/r18.txt"
        "cat /dev/null > $TMP_DIR/r19.txt; cat $TMP_DIR/r19.txt"
        "echo -n test > $TMP_DIR/r20.txt; cat $TMP_DIR/r20.txt"
        "echo test > $TMP_DIR/r21.txt; cat < $TMP_DIR/r21.txt > $TMP_DIR/r22.txt; cat $TMP_DIR/r22.txt"
        "echo a b c > $TMP_DIR/r23.txt; cat $TMP_DIR/r23.txt"
        "ls | cat > $TMP_DIR/r24.txt; cat $TMP_DIR/r24.txt | wc -l"
        "echo test | cat > $TMP_DIR/r25.txt; cat $TMP_DIR/r25.txt"
        "cat < /dev/null | cat > $TMP_DIR/r26.txt"
        "echo test > $TMP_DIR/r27.txt; cat $TMP_DIR/r27.txt > $TMP_DIR/r28.txt; cat $TMP_DIR/r28.txt > $TMP_DIR/r29.txt"
        "echo a > $TMP_DIR/r30.txt; echo b > $TMP_DIR/r30.txt; echo c > $TMP_DIR/r30.txt; cat $TMP_DIR/r30.txt"
        "echo test >> $TMP_DIR/r31.txt; echo test >> $TMP_DIR/r31.txt; cat $TMP_DIR/r31.txt"
        "cat < /dev/null > $TMP_DIR/r32.txt; cat $TMP_DIR/r32.txt | wc -l"
        "echo multi word test > $TMP_DIR/r33.txt; cat $TMP_DIR/r33.txt"
        "echo -n > $TMP_DIR/r34.txt; cat $TMP_DIR/r34.txt"
        "ls > $TMP_DIR/r35.txt 2>&1; cat $TMP_DIR/r35.txt | head -3"
        "echo test > $TMP_DIR/r36.txt; cat $TMP_DIR/r36.txt; rm $TMP_DIR/r36.txt"
        "echo a >> $TMP_DIR/r37.txt; echo b >> $TMP_DIR/r37.txt; cat $TMP_DIR/r37.txt | wc -l"
        "cat /dev/null > $TMP_DIR/r38.txt; cat < $TMP_DIR/r38.txt"
    )

    for test_cmd in "${redir_tests[@]}"; do
        run_and_compare "$test_cmd" "redir ultra: ${test_cmd:0:20}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_variables_ultra() {
    print_section "TEST 31: Variables - Ultra Extended (60+ tests)"
    echo "Test 31: Variables Ultra" >> "$REPORT_FILE"

    print_test_header "Testing variables with 60+ scenarios..."

    local var_tests=(
        "echo \$HOME | cat"
        "echo \$PATH | wc -l"
        "echo \$USER | cat"
        "echo \$PWD | cat"
        "echo \$SHELL | cat"
        "echo \$HOME\$USER"
        "echo \$HOME:\$USER"
        "echo \$HOME/\$USER"
        "echo \$HOME-\$USER"
        "echo prefix\$HOMEsuffix"
        "echo \$HOME\$HOME\$HOME"
        "echo '\$HOME'"
        "echo \"\$HOME\""
        "echo '\$HOME\$USER'"
        "echo \"\$HOME\$USER\""
        "echo \$NONEXIST"
        "echo prefix\$NONEXISTsuffix"
        "echo \$NONEXIST\$HOME"
        "echo \$HOME\$NONEXIST"
        "echo \$?"
        "echo \$? \$?"
        "/bin/true; echo \$?"
        "/bin/false; echo \$?"
        "echo test; echo \$?"
        "ls /nonexistent 2>/dev/null; echo \$?"
        "echo \$\$"
        "echo \$\$ \$\$"
        "echo prefix\$\$suffix"
        "echo \$1"
        "echo \$2"
        "echo \$0"
        "echo \$@"
        "echo \$*"
        "echo \$#"
        "echo \$-"
        "echo \$!"
        "echo \${HOME}"
        "echo \${USER}"
        "echo \${PATH}"
        "echo \${NONEXIST}"
        "echo \$HOME/test"
        "echo \$HOME/test/file"
        "echo /home/\$USER"
        "echo test=\$HOME"
        "echo \$HOME=test"
        "export TEST_VAR=value; echo \$TEST_VAR"
        "export TEST_VAR=value; echo prefix\$TEST_VARsuffix"
        "export TEST_VAR='a b c'; echo \$TEST_VAR"
        "export TEST_VAR=''; echo \$TEST_VAR"
        "export TEST_VAR=' '; echo \$TEST_VAR"
        "export TEST_VAR=\$HOME; echo \$TEST_VAR"
        "export VAR1=a VAR2=b; echo \$VAR1 \$VAR2"
        "unset HOME; echo \$HOME"
        "export TEST=123; echo \$TEST"
        "export TEST=abc; echo \"\$TEST\""
        "export TEST=xyz; echo '\$TEST'"
        "echo \$HOME | grep home"
        "echo \$PATH | grep /"
        "echo \$USER | cat | cat"
        "echo \$HOME\$PATH\$USER | wc -c"
        "echo test\$HOMEtest | cat"
    )

    for test_cmd in "${var_tests[@]}"; do
        run_and_compare "$test_cmd" "var ultra: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_builtins_ultra() {
    print_section "TEST 32: Builtins - Ultra Comprehensive (70+ tests)"
    echo "Test 32: Builtins Ultra" >> "$REPORT_FILE"

    print_test_header "Testing builtins with 70+ scenarios..."

    # pwd tests
    run_and_compare "pwd" "builtin: pwd"
    run_and_compare "pwd | cat" "builtin: pwd pipe"
    run_and_compare "pwd; pwd; pwd" "builtin: pwd triple"
    run_and_compare "pwd > /dev/null" "builtin: pwd redirect"
    run_and_compare "pwd 2>&1" "builtin: pwd stderr"

    # cd tests
    run_and_compare "cd; pwd" "builtin: cd home"
    run_and_compare "cd /; pwd" "builtin: cd root"
    run_and_compare "cd /tmp; pwd" "builtin: cd tmp"
    run_and_compare "cd ..; pwd" "builtin: cd parent"
    run_and_compare "cd .; pwd" "builtin: cd current"
    run_and_compare "cd /nonexistent; echo \$?" "builtin: cd fail"
    run_and_compare "cd /tmp; cd ..; pwd" "builtin: cd chain"
    run_and_compare "cd; cd /tmp; pwd" "builtin: cd home tmp"
    run_and_compare "cd /; cd; pwd" "builtin: cd root home"

    # echo tests
    run_and_compare "echo" "builtin: echo empty"
    run_and_compare "echo ''" "builtin: echo empty str"
    run_and_compare "echo -n" "builtin: echo -n only"
    run_and_compare "echo -n ''" "builtin: echo -n empty"
    run_and_compare "echo -n test" "builtin: echo -n test"
    run_and_compare "echo -n -n test" "builtin: echo -n -n"
    run_and_compare "echo -n -n -n test" "builtin: echo -n x3"
    run_and_compare "echo test; echo test2" "builtin: echo multi"
    run_and_compare "echo a b c d e" "builtin: echo multi args"
    run_and_compare "echo 'a b c'" "builtin: echo quoted"

    # env tests
    run_and_compare "env | grep PATH" "builtin: env grep"
    run_and_compare "env | grep HOME" "builtin: env home"
    run_and_compare "env | grep USER" "builtin: env user"
    run_and_compare "env | wc -l" "builtin: env count"
    run_and_compare "env | cat | cat" "builtin: env pipe"

    # export tests
    run_and_compare "export TEST=1; echo \$TEST" "builtin: export num"
    run_and_compare "export TEST=abc; echo \$TEST" "builtin: export str"
    run_and_compare "export TEST='a b'; echo \$TEST" "builtin: export space"
    run_and_compare "export TEST=''; echo \$TEST" "builtin: export empty"
    run_and_compare "export TEST=\$HOME; echo \$TEST" "builtin: export var"
    run_and_compare "export A=1 B=2; echo \$A \$B" "builtin: export multi"
    run_and_compare "export TEST=1; export TEST=2; echo \$TEST" "builtin: export override"
    run_and_compare "export PATH=test; echo \$PATH" "builtin: export path"
    run_and_compare "export | grep TEST" "builtin: export list"
    run_and_compare "export TEST=123; unset TEST; echo \$TEST" "builtin: export unset"

    # unset tests
    run_and_compare "export TEST=1; unset TEST; echo \$TEST" "builtin: unset test"
    run_and_compare "unset PATH; echo \$PATH" "builtin: unset path"
    run_and_compare "unset NONEXIST" "builtin: unset nonexist"
    run_and_compare "export A=1 B=2; unset A; echo \$A \$B" "builtin: unset one"
    run_and_compare "unset HOME; unset USER; unset PWD" "builtin: unset multi"

    # exit tests
    run_and_compare "exit 0" "builtin: exit 0"
    run_and_compare "exit 1" "builtin: exit 1"
    run_and_compare "exit 42" "builtin: exit 42"
    run_and_compare "exit 255" "builtin: exit 255"
    run_and_compare "exit 256" "builtin: exit 256"
    run_and_compare "exit -1" "builtin: exit -1"
    run_and_compare "exit abc" "builtin: exit invalid"
    run_and_compare "exit 999" "builtin: exit large"

    # combinations
    run_and_compare "cd /tmp; pwd; cd; pwd" "builtin: cd pwd combo"
    run_and_compare "export TEST=val; echo \$TEST; unset TEST; echo \$TEST" "builtin: export echo unset"
    run_and_compare "pwd | cat | cat | cat" "builtin: pwd multi pipe"
    run_and_compare "echo test | cat; pwd | cat" "builtin: echo pwd pipe"
    run_and_compare "cd /; pwd; cd /tmp; pwd" "builtin: cd navigation"

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_quotes_ultra() {
    print_section "TEST 33: Quotes - Ultra Extended (50+ tests)"
    echo "Test 33: Quotes Ultra" >> "$REPORT_FILE"

    print_test_header "Testing quotes with 50+ scenarios..."

    local quote_tests=(
        "echo 'simple'"
        "echo \"simple\""
        "echo 'a b c'"
        "echo \"a b c\""
        "echo 'test\"test'"
        "echo \"test'test\""
        "echo 'it\\'s'"
        "echo \"it's\""
        "echo '\"'"
        "echo \"'\""
        "echo '\"\"\"'"
        "echo \"'''\""
        "echo '\$HOME'"
        "echo \"\$HOME\""
        "echo 'test\$HOME'"
        "echo \"test\$HOME\""
        "echo '\$HOME\$USER'"
        "echo \"\$HOME\$USER\""
        "echo '  spaces  '"
        "echo \"  spaces  \""
        "echo 'multiple  spaces'"
        "echo \"multiple  spaces\""
        "echo 'a'b'c'"
        "echo \"a\"b\"c\""
        "echo a'b'c"
        "echo a\"b\"c"
        "echo 'a\"b\"c'"
        "echo \"a'b'c\""
        "echo ''"
        "echo \"\""
        "echo '' ''"
        "echo \"\" \"\""
        "echo 'test' \"test\""
        "echo \"test\" 'test'"
        "echo 'a b' 'c d'"
        "echo \"a b\" \"c d\""
        "echo test'with'quotes"
        "echo test\"with\"quotes"
        "echo 'start' middle 'end'"
        "echo \"start\" middle \"end\""
        "echo '\\\$HOME'"
        "echo \"\\\$HOME\""
        "echo '\\n\\t'"
        "echo \"\\n\\t\""
        "echo 'special!@#\$%'"
        "echo \"special!@#\$%\""
        "echo '|><&;'"
        "echo \"|><&;\""
        "echo 'test | test'"
        "echo \"test | test\""
    )

    for test_cmd in "${quote_tests[@]}"; do
        run_and_compare "$test_cmd" "quote ultra: ${test_cmd:0:25}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_wildcards_ultra() {
    print_section "TEST 34: Wildcards - Ultra Complete (40+ tests)"
    echo "Test 34: Wildcards Ultra" >> "$REPORT_FILE"

    print_test_header "Testing wildcards with 40+ scenarios..."

    mkdir -p "$TMP_DIR/wildtest2"
    touch "$TMP_DIR/wildtest2/a.txt"
    touch "$TMP_DIR/wildtest2/b.txt"
    touch "$TMP_DIR/wildtest2/ab.txt"
    touch "$TMP_DIR/wildtest2/abc.txt"
    touch "$TMP_DIR/wildtest2/test.sh"
    touch "$TMP_DIR/wildtest2/test.c"
    touch "$TMP_DIR/wildtest2/file1"
    touch "$TMP_DIR/wildtest2/file2"
    touch "$TMP_DIR/wildtest2/file10"

    local wild_tests=(
        "ls $TMP_DIR/wildtest2/*.txt"
        "ls $TMP_DIR/wildtest2/*.sh"
        "ls $TMP_DIR/wildtest2/*.c"
        "ls $TMP_DIR/wildtest2/*"
        "ls $TMP_DIR/wildtest2/a*"
        "ls $TMP_DIR/wildtest2/b*"
        "ls $TMP_DIR/wildtest2/*a*"
        "ls $TMP_DIR/wildtest2/*b*"
        "ls $TMP_DIR/wildtest2/file*"
        "ls $TMP_DIR/wildtest2/file?"
        "ls $TMP_DIR/wildtest2/file??"
        "ls $TMP_DIR/wildtest2/???.txt"
        "ls $TMP_DIR/wildtest2/????.txt"
        "ls $TMP_DIR/wildtest2/test.*"
        "echo $TMP_DIR/wildtest2/*.txt"
        "echo $TMP_DIR/wildtest2/*"
        "cat $TMP_DIR/wildtest2/*.txt 2>/dev/null"
        "ls $TMP_DIR/wildtest2/*.* 2>&1 | wc -l"
        "ls $TMP_DIR/wildtest2/[ab]*.txt"
        "ls $TMP_DIR/wildtest2/[ab].txt"
        "ls $TMP_DIR/wildtest2/[a-z].txt"
        "ls $TMP_DIR/wildtest2/file[12]"
        "ls $TMP_DIR/wildtest2/file[0-9]"
        "ls $TMP_DIR/wildtest2/file[0-9]*"
        "echo '*.txt'"
        "echo \"*.txt\""
        "ls $TMP_DIR/wildtest2/* | wc -l"
        "ls $TMP_DIR/wildtest2/*.* | wc -l"
        "ls $TMP_DIR/wildtest2/a* | cat"
        "ls $TMP_DIR/wildtest2/b* | cat"
        "ls $TMP_DIR/wildtest2/* | grep txt"
        "ls $TMP_DIR/wildtest2/* | grep test"
        "echo $TMP_DIR/wildtest2/* | wc -w"
        "ls $TMP_DIR/wildtest2/*.txt | wc -l"
        "ls $TMP_DIR/wildtest2/file* | wc -l"
        "ls $TMP_DIR/wildtest2/test.* | wc -l"
        "ls $TMP_DIR/wildtest2/??? | wc -l"
        "ls $TMP_DIR/wildtest2/???? | wc -l"
        "ls $TMP_DIR/wildtest2/?????.* | wc -l"
        "echo $TMP_DIR/wildtest2/a*.txt"
    )

    for test_cmd in "${wild_tests[@]}"; do
        run_and_compare "$test_cmd" "wild ultra: ${test_cmd:0:20}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_error_handling() {
    print_section "TEST 35: Error Handling - Comprehensive (30+ tests)"
    echo "Test 35: Error Handling" >> "$REPORT_FILE"

    print_test_header "Testing error handling with 30+ scenarios..."

    local error_tests=(
        "ls /nonexistent 2>&1"
        "cat /nonexistent/file 2>&1"
        "cd /nonexistent/dir 2>&1; echo \$?"
        "mkdir /nonexistent/dir 2>&1"
        "rm /nonexistent/file 2>&1"
        "chmod 777 /nonexistent 2>&1"
        "chown user /nonexistent 2>&1"
        "./nonexistent_binary 2>&1"
        "/nonexistent/path/cmd 2>&1"
        "nonexistentcmd 2>&1"
        "cat < /nonexistent 2>&1"
        "echo test > /nonexistent/file 2>&1"
        "ls /root 2>&1"
        "cat /etc/shadow 2>&1"
        "cd /root 2>&1; echo \$?"
        "export 123INVALID=test 2>&1"
        "export =test 2>&1"
        "export TEST 2>&1"
        "unset 123INVALID 2>&1"
        "exit abc 2>&1"
        "exit 99999 2>&1"
        "cd 2>&1; echo \$?"
        "cd /tmp /home 2>&1"
        "pwd arg1 arg2 2>&1"
        "env arg1 arg2 2>&1"
        "ls -invalid_flag 2>&1"
        "cat -invalid_flag file 2>&1"
        "echo test | nonexistent 2>&1"
        "nonexistent | echo test 2>&1"
        "ls | nonexistent | cat 2>&1"
    )

    for test_cmd in "${error_tests[@]}"; do
        ((TESTS_TOTAL++))
        echo -e "$test_cmd\nexit" > "$TMP_DIR/test.txt"
        timeout 10 bash -c "cat '$TMP_DIR/test.txt' | $MINISHELL > /dev/null 2>&1"

        if [ $? -ne 124 ]; then
            print_pass "Error handling: ${test_cmd:0:30}"
            echo "  ✓ error: $test_cmd" >> "$REPORT_FILE"
            ((TESTS_PASSED++))
        else
            print_fail "Error handling timeout: ${test_cmd:0:30}"
            FAILED_TESTS+=("Error: $test_cmd")
            FAILED_DETAILS+=("Command timed out on error")
            echo "  ✗ error: $test_cmd" >> "$REPORT_FILE"
            ((TESTS_FAILED++))
        fi
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_mixed_complex() {
    print_section "TEST 36: Mixed Complex Commands (40+ tests)"
    echo "Test 36: Mixed Complex" >> "$REPORT_FILE"

    print_test_header "Testing complex mixed scenarios..."

    local complex_tests=(
        "export VAR=test; echo \$VAR | cat"
        "cd /tmp; pwd | cat; cd"
        "echo \$HOME | cat | cat | cat"
        "ls | grep test | cat | wc -l"
        "echo test > $TMP_DIR/f.txt; cat $TMP_DIR/f.txt | cat"
        "export A=1; export B=2; echo \$A \$B | cat"
        "pwd; cd /tmp; pwd; cd; pwd"
        "echo a | cat; echo b | cat; echo c | cat"
        "ls | head -5 | cat | wc -l"
        "echo \$PATH | cat | grep /"
        "export TEST=val; unset TEST; echo \$TEST"
        "echo test | cat > $TMP_DIR/x.txt; cat $TMP_DIR/x.txt"
        "ls | cat | cat | cat | wc -l"
        "echo \$HOME\$USER | cat | cat"
        "pwd | cat; ls | cat | head -3"
        "export X=1 Y=2; echo \$X; echo \$Y"
        "echo 'test' | cat | cat | grep test"
        "cat /dev/null | cat | cat"
        "echo -n test | cat | cat"
        "ls > $TMP_DIR/ls.txt; cat $TMP_DIR/ls.txt | wc -l"
        "echo a; echo b; echo c"
        "pwd; pwd; pwd"
        "echo \$HOME | cat | cat | cat | cat"
        "export VAR=\$HOME; echo \$VAR"
        "cd /; pwd; cd /tmp; pwd; cd"
        "echo test test test | cat | grep test | wc -l"
        "ls | cat > $TMP_DIR/out.txt; cat $TMP_DIR/out.txt | head -1"
        "echo 'a b c' | cat | cat | cat"
        "export A=a B=b C=c; echo \$A \$B \$C"
        "pwd | cat | cat | cat | cat | cat"
        "echo \$PATH\$HOME | cat"
        "ls | head -10 | tail -5 | cat"
        "echo test | cat | cat | cat | cat | cat | cat"
        "export TEST=123; echo \$TEST | cat"
        "cd /tmp; ls | wc -l; cd"
        "echo a > $TMP_DIR/a.txt; echo b >> $TMP_DIR/a.txt; cat $TMP_DIR/a.txt"
        "pwd; cd /; pwd; cd /tmp; pwd"
        "echo 'test string' | cat | cat | cat"
        "export VAR='a b c'; echo \$VAR | cat"
        "ls | cat | cat | cat | cat | wc -l"
    )

    for test_cmd in "${complex_tests[@]}"; do
        run_and_compare "$test_cmd" "complex: ${test_cmd:0:20}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

test_stress_extended() {
    print_section "TEST 37: Stress Testing Extended (20+ tests)"
    echo "Test 37: Stress Extended" >> "$REPORT_FILE"

    print_test_header "Testing stress scenarios..."

    # Create large file
    seq 1 50000 > "$TMP_DIR/huge2.txt"

    local stress_tests=(
        "cat $TMP_DIR/huge2.txt | wc -l"
        "cat $TMP_DIR/huge2.txt | head -10000 | wc -l"
        "cat $TMP_DIR/huge2.txt | tail -10000 | wc -l"
        "cat $TMP_DIR/huge2.txt | grep 1 | wc -l"
        "cat $TMP_DIR/huge2.txt | head -25000 | tail -1000 | wc -l"
        "seq 1 1000 | cat | cat | cat | cat | cat"
        "seq 1 5000 | grep 1 | wc -l"
        "seq 1 10000 | head -5000 | tail -2500 | wc -l"
        "cat $TMP_DIR/huge2.txt | cat | cat | wc -l"
        "cat $TMP_DIR/huge2.txt | grep 2 | grep 2 | wc -l"
        "seq 1 100 | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat"
        "cat $TMP_DIR/huge2.txt | head -1"
        "cat $TMP_DIR/huge2.txt | tail -1"
        "cat $TMP_DIR/huge2.txt | head -100 | grep 5"
        "seq 1 10000 | wc -l"
        "seq 1 20000 | head -10000 | wc -l"
        "cat $TMP_DIR/huge2.txt | grep 3 | head -100 | wc -l"
        "seq 1 1000 | cat | cat | cat | wc -l"
        "cat $TMP_DIR/huge2.txt | head -30000 | tail -20000 | wc -l"
        "seq 1 5000 | cat | wc -l"
    )

    for test_cmd in "${stress_tests[@]}"; do
        run_and_compare "$test_cmd" "stress: ${test_cmd:0:20}"
    done

    echo ""
    echo "" >> "$REPORT_FILE"
}

# ============================================================================ #
#                       CATEGORY RESULTS NAVIGATION                            #
# ============================================================================ #

browse_results_by_category() {
    if [ ${#CATEGORY_NAMES[@]} -eq 0 ]; then
        clear
        print_header
        echo -e "${YELLOW}${BOLD}No test results available yet.${RESET}"
        echo -e "${DIM}Run some tests first, then browse results by category.${RESET}\n"
        echo -ne "${DIM}Press Enter to continue...${RESET}"
        read
        return
    fi

    while true; do
        clear
        print_header
        echo -e "${CYAN}${BOLD}╔════════════════════════════════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                       BROWSE RESULTS BY CATEGORY                                  ${RESET}${CYAN}${BOLD}║${RESET}"
        echo -e "${CYAN}${BOLD}╠════════════════════════════════════════════════════════════════════════════════════╣${RESET}"
        echo -e "${CYAN}${BOLD}║${RESET} ${WHITE}${BOLD}#  │ Category Name                              │ Status    │ Pass Rate        ${RESET}${CYAN}${BOLD}║${RESET}"
        echo -e "${CYAN}${BOLD}╠════════════════════════════════════════════════════════════════════════════════════╣${RESET}"

        # Get all category numbers and sort them
        local cat_nums=($(printf '%s\n' "${!CATEGORY_NAMES[@]}" | sort -n))

        for cat_num in "${cat_nums[@]}"; do
            local cat_name="${CATEGORY_NAMES[$cat_num]}"
            local passed=${CATEGORY_PASSED[$cat_num]:-0}
            local failed=${CATEGORY_FAILED[$cat_num]:-0}
            local total=${CATEGORY_TOTAL[$cat_num]:-0}

            local percentage=0
            if [ $total -gt 0 ]; then
                percentage=$((passed * 100 / total))
            fi

            # Truncate category name to fit (increased from 30 to 42)
            cat_name="${cat_name:0:42}"

            local status_icon="✓"
            local status_color=$GREEN
            if [ $failed -gt 0 ]; then
                status_icon="✗"
                status_color=$RED
            fi

            printf "${CYAN}${BOLD}║${RESET} ${YELLOW}%2d${RESET} │ %-42s │ ${status_color}%-9s${RESET} │ " "$cat_num" "$cat_name" "$status_icon $failed fail"

            # Color code percentage
            local pct_color=$GREEN
            if [ $percentage -lt 100 ]; then pct_color=$YELLOW; fi
            if [ $percentage -lt 80 ]; then pct_color=$RED; fi

            printf "${pct_color}%d/%d (%3d%%)${RESET}  ${CYAN}${BOLD}║${RESET}\n" $passed $total $percentage
        done

        echo -e "${CYAN}${BOLD}╚════════════════════════════════════════════════════════════════════════════════════╝${RESET}"
        echo ""
        echo -e "${DIM}Enter category number to view details, or 'm' to return to main menu${RESET}"
        echo -ne "${BOLD}${CYAN}➤ Your choice: ${RESET}"
        read -r choice

        # Check if return to menu
        if [[ "$choice" == "m" ]] || [[ "$choice" == "menu" ]]; then
            return
        fi

        # Check if valid category number
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ -n "${CATEGORY_NAMES[$choice]}" ]; then
            show_category_details "$choice"
        else
            echo -e "${RED}Invalid choice. Press Enter to try again...${RESET}"
            read
        fi
    done
}

show_category_details() {
    local cat_num=$1
    local cat_name="${CATEGORY_NAMES[$cat_num]}"
    local passed=${CATEGORY_PASSED[$cat_num]:-0}
    local failed=${CATEGORY_FAILED[$cat_num]:-0}
    local total=${CATEGORY_TOTAL[$cat_num]:-0}
    local failed_tests="${CATEGORY_FAILED_TESTS[$cat_num]:-}"

    clear
    print_header
    echo -e "${BLUE}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    printf "${BLUE}${BOLD}║${RESET} ${YELLOW}${BOLD}TEST #%2d${RESET} ${CYAN}│${RESET} %-58s ${BLUE}${BOLD}║${RESET}\n" "$cat_num" "$cat_name"
    echo -e "${BLUE}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BLUE}${BOLD}║${RESET}                                                                          ${BLUE}${BOLD}║${RESET}"
    printf "${BLUE}${BOLD}║${RESET}   ${WHITE}Total Tests:${RESET}      ${CYAN}${BOLD}%-6d${RESET}                                             ${BLUE}${BOLD}║${RESET}\n" $total
    printf "${BLUE}${BOLD}║${RESET}   ${GREEN}Tests Passed:${RESET}     ${GREEN}${BOLD}%-6d${RESET}                                             ${BLUE}${BOLD}║${RESET}\n" $passed
    printf "${BLUE}${BOLD}║${RESET}   ${RED}Tests Failed:${RESET}     ${RED}${BOLD}%-6d${RESET}                                             ${BLUE}${BOLD}║${RESET}\n" $failed

    local percentage=0
    if [ $total -gt 0 ]; then
        percentage=$((passed * 100 / total))
    fi

    local pct_color=$GREEN
    if [ $percentage -lt 100 ]; then pct_color=$YELLOW; fi
    if [ $percentage -lt 80 ]; then pct_color=$RED; fi

    printf "${BLUE}${BOLD}║${RESET}   ${WHITE}Success Rate:${RESET}     ${pct_color}${BOLD}%-3d%%${RESET}                                               ${BLUE}${BOLD}║${RESET}\n" $percentage
    echo -e "${BLUE}${BOLD}║${RESET}                                                                          ${BLUE}${BOLD}║${RESET}"
    echo -e "${BLUE}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"

    # Show failed tests if any
    if [ $failed -gt 0 ] && [ -n "$failed_tests" ]; then
        echo ""
        echo -e "${RED}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${RED}${BOLD}║${RESET}${WHITE}${BOLD}                        FAILED TESTS                                     ${RESET}${RED}${BOLD}║${RESET}"
        echo -e "${RED}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"

        # Split failed tests by delimiter
        IFS='|' read -ra failed_array <<< "$failed_tests"
        local count=1
        for test in "${failed_array[@]}"; do
            if [ -n "$test" ]; then
                printf "${RED}${BOLD}║${RESET} ${YELLOW}%2d.${RESET} %-66s ${RED}${BOLD}║${RESET}\n" "$count" "$test"
                ((count++))
            fi
        done

        echo -e "${RED}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    else
        echo ""
        echo -e "${GREEN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${GREEN}${BOLD}║${RESET}  ${WHITE}${BOLD}✓ All tests in this category PASSED!${RESET}                                ${GREEN}${BOLD}║${RESET}"
        echo -e "${GREEN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    fi

    echo ""
    echo -ne "${DIM}Press Enter to return to category list...${RESET}"
    read
}

# ============================================================================ #
#                            INTERACTIVE MODE                                  #
# ============================================================================ #

interactive_mode() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                       INTERACTIVE TEST MODE                              ${RESET}${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}Test your own commands and compare outputs side-by-side${RESET}              ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}                                                                          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${DIM}Commands:${RESET}                                                                ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}'quit'${RESET} or ${WHITE}'exit'${RESET} - Return to main menu                              ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}'clear'${RESET}        - Clear screen                                       ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}Any command${RESET}   - Test it!                                           ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""

    local test_count=0
    local match_count=0
    local diff_count=0

    while true; do
        echo ""
        echo -ne "${BOLD}${CYAN}➤ Enter command${RESET} ${DIM}(or 'quit' to exit)${RESET}: "
        read -r user_cmd

        # Check for exit commands
        if [[ "$user_cmd" == "quit" ]] || [[ "$user_cmd" == "exit" ]]; then
            echo ""
            echo -e "${GREEN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
            echo -e "${GREEN}${BOLD}║${RESET}                    INTERACTIVE SESSION SUMMARY                           ${GREEN}${BOLD}║${RESET}"
            echo -e "${GREEN}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
            printf "${GREEN}${BOLD}║${RESET}   ${WHITE}Commands tested:${RESET}  %3d                                                 ${GREEN}${BOLD}║${RESET}\n" $test_count
            printf "${GREEN}${BOLD}║${RESET}   ${GREEN}Matches:${RESET}          %3d                                                 ${GREEN}${BOLD}║${RESET}\n" $match_count
            printf "${GREEN}${BOLD}║${RESET}   ${RED}Differences:${RESET}      %3d                                                 ${GREEN}${BOLD}║${RESET}\n" $diff_count
            echo -e "${GREEN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
            echo ""
            echo -ne "${DIM}Press Enter to return to menu...${RESET}"
            read
            return
        fi

        # Clear screen command
        if [[ "$user_cmd" == "clear" ]]; then
            clear
            print_header
            echo -e "${CYAN}Interactive Test Mode${RESET} - Commands tested: ${WHITE}$test_count${RESET}"
            continue
        fi

        # Skip empty commands
        if [[ -z "$user_cmd" ]]; then
            continue
        fi

        ((test_count++))

        echo ""
        echo -e "${YELLOW}${BOLD}════════════════════════════════════════════════════════════════════════════${RESET}"
        echo -e "${YELLOW}${BOLD}Testing:${RESET} ${WHITE}$user_cmd${RESET}"
        echo -e "${YELLOW}${BOLD}════════════════════════════════════════════════════════════════════════════${RESET}"

        # Execute with bash
        local bash_out=$(mktemp)
        local bash_err=$(mktemp)
        bash -c "$user_cmd" > "$bash_out" 2> "$bash_err"
        local bash_exit=$?
        local bash_stdout=$(cat "$bash_out")
        local bash_stderr=$(cat "$bash_err")

        # Execute with minishell
        local ms_out=$(mktemp)
        local ms_err=$(mktemp)
        echo "$user_cmd" | $MINISHELL > "$ms_out" 2> "$ms_err"
        local ms_exit=$?
        local ms_stdout=$(cat "$ms_out")
        local ms_stderr=$(cat "$ms_err")

        # Display side by side
        echo ""
        echo -e "${CYAN}${BOLD}╔════════════════════════════════╦════════════════════════════════╗${RESET}"
        echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}          BASH OUTPUT           ${RESET}${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}       MINISHELL OUTPUT        ${RESET}${CYAN}${BOLD}║${RESET}"
        echo -e "${CYAN}${BOLD}╠════════════════════════════════╬════════════════════════════════╣${RESET}"

        # Split outputs into lines and display side by side
        IFS=$'\n' read -rd '' -a bash_lines <<< "$bash_stdout"
        IFS=$'\n' read -rd '' -a ms_lines <<< "$ms_stdout"

        local max_lines=${#bash_lines[@]}
        if [ ${#ms_lines[@]} -gt $max_lines ]; then
            max_lines=${#ms_lines[@]}
        fi

        if [ $max_lines -eq 0 ]; then
            echo -e "${CYAN}${BOLD}║${RESET} ${DIM}(no output)${RESET}                    ${CYAN}${BOLD}║${RESET} ${DIM}(no output)${RESET}                    ${CYAN}${BOLD}║${RESET}"
        else
            for ((i=0; i<max_lines; i++)); do
                local bash_line="${bash_lines[$i]:-}"
                local ms_line="${ms_lines[$i]:-}"

                # Truncate lines to fit
                bash_line="${bash_line:0:30}"
                ms_line="${ms_line:0:30}"

                # Color code based on match
                if [[ "$bash_line" == "$ms_line" ]]; then
                    printf "${CYAN}${BOLD}║${RESET} ${GREEN}%-30s${RESET} ${CYAN}${BOLD}║${RESET} ${GREEN}%-30s${RESET} ${CYAN}${BOLD}║${RESET}\n" "$bash_line" "$ms_line"
                else
                    printf "${CYAN}${BOLD}║${RESET} ${YELLOW}%-30s${RESET} ${CYAN}${BOLD}║${RESET} ${YELLOW}%-30s${RESET} ${CYAN}${BOLD}║${RESET}\n" "$bash_line" "$ms_line"
                fi
            done
        fi

        echo -e "${CYAN}${BOLD}╠════════════════════════════════╬════════════════════════════════╣${RESET}"

        # Exit codes
        local exit_color_bash=$GREEN
        local exit_color_ms=$GREEN
        if [ $bash_exit -ne $ms_exit ]; then
            exit_color_bash=$RED
            exit_color_ms=$RED
        fi

        printf "${CYAN}${BOLD}║${RESET} ${WHITE}Exit Code:${RESET} ${exit_color_bash}%-16d${RESET} ${CYAN}${BOLD}║${RESET} ${WHITE}Exit Code:${RESET} ${exit_color_ms}%-16d${RESET} ${CYAN}${BOLD}║${RESET}\n" $bash_exit $ms_exit
        echo -e "${CYAN}${BOLD}╚════════════════════════════════╩════════════════════════════════╝${RESET}"

        # Check if stderr is present
        if [[ -n "$bash_stderr" ]] || [[ -n "$ms_stderr" ]]; then
            echo ""
            echo -e "${YELLOW}${BOLD}STDERR Output:${RESET}"
            echo -e "${CYAN}${BOLD}╔════════════════════════════════╦════════════════════════════════╗${RESET}"
            echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}             BASH               ${RESET}${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}          MINISHELL             ${RESET}${CYAN}${BOLD}║${RESET}"
            echo -e "${CYAN}${BOLD}╠════════════════════════════════╬════════════════════════════════╣${RESET}"

            IFS=$'\n' read -rd '' -a bash_err_lines <<< "$bash_stderr"
            IFS=$'\n' read -rd '' -a ms_err_lines <<< "$ms_stderr"

            local max_err_lines=${#bash_err_lines[@]}
            if [ ${#ms_err_lines[@]} -gt $max_err_lines ]; then
                max_err_lines=${#ms_err_lines[@]}
            fi

            if [ $max_err_lines -eq 0 ]; then
                echo -e "${CYAN}${BOLD}║${RESET} ${DIM}(no errors)${RESET}                    ${CYAN}${BOLD}║${RESET} ${DIM}(no errors)${RESET}                    ${CYAN}${BOLD}║${RESET}"
            else
                for ((i=0; i<max_err_lines; i++)); do
                    local bash_err_line="${bash_err_lines[$i]:-}"
                    local ms_err_line="${ms_err_lines[$i]:-}"
                    bash_err_line="${bash_err_line:0:30}"
                    ms_err_line="${ms_err_line:0:30}"
                    printf "${CYAN}${BOLD}║${RESET} ${RED}%-30s${RESET} ${CYAN}${BOLD}║${RESET} ${RED}%-30s${RESET} ${CYAN}${BOLD}║${RESET}\n" "$bash_err_line" "$ms_err_line"
                done
            fi

            echo -e "${CYAN}${BOLD}╚════════════════════════════════╩════════════════════════════════╝${RESET}"
        fi

        # Overall result
        echo ""
        if [[ "$bash_stdout" == "$ms_stdout" ]] && [ $bash_exit -eq $ms_exit ]; then
            echo -e "${GREEN}${BOLD}✓ MATCH${RESET} - Outputs and exit codes are identical!"
            ((match_count++))
        else
            echo -e "${RED}${BOLD}✗ DIFFERENCE${RESET} - Outputs or exit codes differ!"
            ((diff_count++))
        fi

        # Cleanup temp files
        rm -f "$bash_out" "$bash_err" "$ms_out" "$ms_err"
    done
}

# ============================================================================ #
#                                    MENU                                      #
# ============================================================================ #

show_help() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                           HELP & SHORTCUTS                               ${RESET}${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}${BOLD}Navigation:${RESET}                                                              ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}1-37${RESET}     Run individual test category                                ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}m${RESET}        Return to main menu                                        ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}h${RESET}        Show this help                                             ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}                                                                          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}${BOLD}Quick Actions:${RESET}                                                           ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}a${RESET}        Run ALL tests (800+ tests)                                 ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}q${RESET}        Quick test (essential features only - ~50 tests)          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}b${RESET}        Basic tests only (tests 1-17)                             ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}n${RESET}        New/Advanced tests only (tests 18-37)                     ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}                                                                          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}${BOLD}Interactive Mode:${RESET}                                                        ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}i${RESET}        Test your own commands (side-by-side comparison)          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}                                                                          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}${BOLD}Reports & Info:${RESET}                                                          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}c${RESET}        Browse results by category                                 ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}r${RESET}        View last report                                           ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}s${RESET}        Show summary of current session                            ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}l${RESET}        List all test categories                                   ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}                                                                          ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}${BOLD}Exit:${RESET}                                                                    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}   ${WHITE}x${RESET}        Exit benchmark                                             ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    echo -ne "${DIM}Press Enter to continue...${RESET}"
    read
}

show_categories_list() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}╔════════════════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                          ALL TEST CATEGORIES                                      ${RESET}${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠════════════════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${WHITE}${BOLD}#  │ Category Name                              │ Tests │ Level    ${RESET}${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠════════════════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}01${RESET} │ Startup Performance                        │  ${DIM}30${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}02${RESET} │ Echo - Hardcore                             │  ${DIM}34${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}03${RESET} │ Echo - Extreme                              │  ${DIM}13${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}04${RESET} │ Syntax Errors                               │  ${DIM}18${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}05${RESET} │ Pipes - Comprehensive                       │  ${DIM}20${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}06${RESET} │ Redirections - Hardcore                     │  ${DIM} 8${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}07${RESET} │ Environment Variables                       │  ${DIM}18${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}08${RESET} │ Quote Handling                              │  ${DIM}30${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}09${RESET} │ Edge Cases                                  │  ${DIM}14${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}10${RESET} │ Builtins - Comprehensive                    │  ${DIM}14${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}11${RESET} │ Stress & Load                               │  ${DIM} 3${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}12${RESET} │ Memory Usage                                │  ${DIM} 1${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}13${RESET} │ Real-World Scenarios                        │  ${DIM} 6${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}14${RESET} │ Exit Codes                                  │  ${DIM}15${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}15${RESET} │ Stdout/Stderr Separation                    │  ${DIM} 9${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}16${RESET} │ Signal Handling                             │  ${DIM} 3${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${CYAN}17${RESET} │ Wildcards & Special                         │  ${DIM}10${RESET}   │ ${GREEN}Basic${RESET}    ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠════════════════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}18${RESET} │ Heredoc - Comprehensive                     │  ${DIM} 5${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}19${RESET} │ Exit Codes - Ultra Strict                   │  ${DIM}10${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}20${RESET} │ Variable Expansion - Advanced               │  ${DIM}20${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}21${RESET} │ Quote Handling - Edge Cases                 │  ${DIM}26${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}22${RESET} │ Pipes - Extreme Multi-Pipe                  │  ${DIM}10${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}23${RESET} │ Redirections - Advanced                     │  ${DIM} 7${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}24${RESET} │ Pipes + Redirections - Combined             │  ${DIM} 7${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}25${RESET} │ Builtins - Edge Cases                       │  ${DIM}30${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}26${RESET} │ Command Not Found                           │  ${DIM} 6${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${YELLOW}27${RESET} │ Paths with Spaces                           │  ${DIM} 8${RESET}   │ ${YELLOW}Advanced${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠════════════════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}28${RESET} │ Echo - Ultra Extended                       │  ${DIM}50${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}29${RESET} │ Pipes - Ultra Comprehensive                 │  ${DIM}50${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}30${RESET} │ Redirections - Ultra Complete               │  ${DIM}40${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}31${RESET} │ Variables - Ultra Extended                  │  ${DIM}60${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}32${RESET} │ Builtins - Ultra Comprehensive              │  ${DIM}70${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}33${RESET} │ Quotes - Ultra Extended                     │  ${DIM}50${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}34${RESET} │ Wildcards - Ultra Complete                  │  ${DIM}40${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}35${RESET} │ Error Handling - Comprehensive              │  ${DIM}30${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}36${RESET} │ Mixed Complex Commands                      │  ${DIM}40${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${RED}37${RESET} │ Stress Testing Extended                     │  ${DIM}20${RESET}   │ ${RED}Ultra   ${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╚════════════════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    echo -ne "${DIM}Press Enter to continue...${RESET}"
    read
}

show_menu() {
    print_header
    echo -e "${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${BOLD}║${RESET}${WHITE}${BOLD}                         MAIN MENU                                        ${RESET}${BOLD}║${RESET}"
    echo -e "${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BOLD}║${RESET}                                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}  ${GREEN}${BOLD}🚀 QUICK START${RESET}                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[a]${RESET} Run ALL tests (37 categories, 800+ tests)                      ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[q]${RESET} Quick Test (essential features, ~50 tests)                     ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[b]${RESET} Basic Tests only (tests 1-17)                                  ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[n]${RESET} Advanced Tests only (tests 18-37)                              ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}                                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BOLD}║${RESET}  ${YELLOW}${BOLD}📋 INDIVIDUAL TESTS${RESET}                                                      ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${DIM}Enter 1-37 to run a specific test category${RESET}                       ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[l]${RESET} List all 37 test categories                                    ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}                                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BOLD}║${RESET}  ${BLUE}${BOLD}🎮 INTERACTIVE MODE${RESET}                                                      ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[i]${RESET} Test your own commands (side-by-side comparison)              ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}                                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BOLD}║${RESET}  ${MAGENTA}${BOLD}📊 REPORTS & INFO${RESET}                                                        ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[c]${RESET} Browse results by category                                     ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[r]${RESET} View last report                                               ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[s]${RESET} Show current session summary                                   ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[h]${RESET} Help & keyboard shortcuts                                      ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}                                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BOLD}║${RESET}  ${RED}${BOLD}❌ EXIT${RESET}                                                                  ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}   ${CYAN}${BOLD}[x]${RESET} Exit benchmark                                                 ${BOLD}║${RESET}"
    echo -e "${BOLD}║${RESET}                                                                          ${BOLD}║${RESET}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    echo -e "${DIM}Tip: Press 'h' for help and keyboard shortcuts${RESET}"
    echo ""
    echo -ne "${BOLD}${CYAN}➤ Your choice: ${RESET}"
}

run_quick_test() {
    TESTS_PASSED=0
    TESTS_FAILED=0
    TESTS_TOTAL=0
    TEST_WARNINGS=0
    FAILED_TESTS=()
    FAILED_DETAILS=()
    QUIET_MODE=1
    TOTAL_TESTS_PLANNED=100

    clear
    print_banner
    echo -e "${CYAN}${BOLD}Starting QUICK TEST MODE...${RESET}"
    echo -e "${YELLOW}Testing essential features only (~100 tests)${RESET}\n"
    sleep 1

    # Essential tests
    test_echo_hardcore
    test_pipes_comprehensive
    test_redirections_hardcore
    test_builtins_comprehensive
    test_exit_codes

    QUIET_MODE=0
    echo ""
    clear
    print_banner
    show_summary
    show_failed_tests
}

run_basic_tests() {
    TESTS_PASSED=0
    TESTS_FAILED=0
    TESTS_TOTAL=0
    TEST_WARNINGS=0
    FAILED_TESTS=()
    FAILED_DETAILS=()
    QUIET_MODE=1
    TOTAL_TESTS_PLANNED=250

    clear
    print_banner
    echo -e "${CYAN}${BOLD}Starting BASIC TESTS...${RESET}"
    echo -e "${YELLOW}Running tests 1-17 (~250 tests)${RESET}\n"
    sleep 1

    test_startup_performance
    test_echo_hardcore
    test_echo_extreme
    test_syntax_errors
    test_pipes_comprehensive
    test_redirections_hardcore
    test_environment_variables_extensive
    test_quotes_comprehensive
    test_edge_cases_extreme
    test_builtins_comprehensive
    test_stress_load
    test_memory_usage
    test_complex_scenarios
    test_exit_codes
    test_stderr_stdout_separation
    test_signal_handling
    test_wildcards_and_special

    QUIET_MODE=0
    echo ""
    clear
    print_banner
    show_summary
    show_failed_tests
}

run_advanced_tests() {
    TESTS_PASSED=0
    TESTS_FAILED=0
    TESTS_TOTAL=0
    TEST_WARNINGS=0
    FAILED_TESTS=()
    FAILED_DETAILS=()
    QUIET_MODE=1
    TOTAL_TESTS_PLANNED=550

    clear
    print_banner
    echo -e "${CYAN}${BOLD}Starting ADVANCED TESTS...${RESET}"
    echo -e "${YELLOW}Running tests 18-37 (Advanced + Ultra - ~550 tests)${RESET}\n"
    sleep 1

    test_heredoc_comprehensive
    test_exit_codes_ultra_strict
    test_variable_expansion_advanced
    test_quotes_edge_cases
    test_pipes_extreme
    test_redirections_advanced
    test_pipes_and_redirections_combined
    test_builtins_edge_cases
    test_command_not_found
    test_paths_with_spaces
    test_echo_ultra_extended
    test_pipes_ultra
    test_redirections_ultra
    test_variables_ultra
    test_builtins_ultra
    test_quotes_ultra
    test_wildcards_ultra
    test_error_handling
    test_mixed_complex
    test_stress_extended

    QUIET_MODE=0
    echo ""
    clear
    print_banner
    show_summary
    show_failed_tests
}

run_test() {
    case $1 in
        1) test_startup_performance ;;
        2) test_echo_hardcore ;;
        3) test_echo_extreme ;;
        4) test_syntax_errors ;;
        5) test_pipes_comprehensive ;;
        6) test_redirections_hardcore ;;
        7) test_environment_variables_extensive ;;
        8) test_quotes_comprehensive ;;
        9) test_edge_cases_extreme ;;
        10) test_builtins_comprehensive ;;
        11) test_stress_load ;;
        12) test_memory_usage ;;
        13) test_complex_scenarios ;;
        14) test_exit_codes ;;
        15) test_stderr_stdout_separation ;;
        16) test_signal_handling ;;
        17) test_wildcards_and_special ;;
        18) test_heredoc_comprehensive ;;
        19) test_exit_codes_ultra_strict ;;
        20) test_variable_expansion_advanced ;;
        21) test_quotes_edge_cases ;;
        22) test_pipes_extreme ;;
        23) test_redirections_advanced ;;
        24) test_pipes_and_redirections_combined ;;
        25) test_builtins_edge_cases ;;
        26) test_command_not_found ;;
        27) test_paths_with_spaces ;;
        28) test_echo_ultra_extended ;;
        29) test_pipes_ultra ;;
        30) test_redirections_ultra ;;
        31) test_variables_ultra ;;
        32) test_builtins_ultra ;;
        33) test_quotes_ultra ;;
        34) test_wildcards_ultra ;;
        35) test_error_handling ;;
        36) test_mixed_complex ;;
        37) test_stress_extended ;;
        q)
            run_quick_test
            ;;
        b)
            run_basic_tests
            ;;
        n)
            run_advanced_tests
            ;;
        a)
            TESTS_PASSED=0
            TESTS_FAILED=0
            TESTS_TOTAL=0
            TEST_WARNINGS=0
            FAILED_TESTS=()
            FAILED_DETAILS=()
            QUIET_MODE=1

            clear
            print_banner
            echo -e "${CYAN}${BOLD}Starting ALL TESTS (37 categories, 800+ tests)...${RESET}"
            echo -e "${YELLOW}Running in quiet mode - showing progress bar only${RESET}\n"
            sleep 1

            test_startup_performance
            test_echo_hardcore
            test_echo_extreme
            test_syntax_errors
            test_pipes_comprehensive
            test_redirections_hardcore
            test_environment_variables_extensive
            test_quotes_comprehensive
            test_edge_cases_extreme
            test_builtins_comprehensive
            test_stress_load
            test_memory_usage
            test_complex_scenarios
            test_exit_codes
            test_stderr_stdout_separation
            test_signal_handling
            test_wildcards_and_special
            test_heredoc_comprehensive
            test_exit_codes_ultra_strict
            test_variable_expansion_advanced
            test_quotes_edge_cases
            test_pipes_extreme
            test_redirections_advanced
            test_pipes_and_redirections_combined
            test_builtins_edge_cases
            test_command_not_found
            test_paths_with_spaces
            test_echo_ultra_extended
            test_pipes_ultra
            test_redirections_ultra
            test_variables_ultra
            test_builtins_ultra
            test_quotes_ultra
            test_wildcards_ultra
            test_error_handling
            test_mixed_complex
            test_stress_extended

            # Disable quiet mode and show results
            QUIET_MODE=0
            echo ""
            clear
            print_banner
            show_summary

            echo ""
            echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
            echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                       NAVIGATION OPTIONS                                 ${RESET}${CYAN}${BOLD}║${RESET}"
            echo -e "${CYAN}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
            echo -e "${CYAN}${BOLD}║${RESET}  ${CYAN}${BOLD}[c]${RESET} Browse results by category                                     ${CYAN}${BOLD}║${RESET}"
            echo -e "${CYAN}${BOLD}║${RESET}  ${CYAN}${BOLD}[f]${RESET} Show all failed tests                                          ${CYAN}${BOLD}║${RESET}"
            echo -e "${CYAN}${BOLD}║${RESET}  ${CYAN}${BOLD}[m]${RESET} Return to main menu                                            ${CYAN}${BOLD}║${RESET}"
            echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
            echo ""
            echo -ne "${BOLD}${CYAN}➤ Your choice: ${RESET}"
            read -r nav_choice

            case $nav_choice in
                c)
                    browse_results_by_category
                    ;;
                f)
                    clear
                    print_header
                    show_failed_tests
                    echo -ne "${DIM}Press Enter to continue...${RESET}"
                    read
                    ;;
                *)
                    # Return to menu
                    ;;
            esac
            ;;
        *) return ;;
    esac

    if [ "$1" != "a" ]; then
        echo ""
        echo -e "${GREEN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${GREEN}${BOLD}║                         ✓ TEST COMPLETED                                 ║${RESET}"
        echo -e "${GREEN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
        echo -e "${CYAN}Report saved to: ${YELLOW}${REPORT_FILE}${RESET}\n"
    fi

    echo -ne "${DIM}Press Enter to continue...${RESET}"
    read
}

show_categories_summary() {
    echo ""
    echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET}${WHITE}${BOLD}                    TEST CATEGORIES BREAKDOWN                             ${RESET}${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${DIM}Category                                         Status      Tests   Rate${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"

    # This would be populated dynamically in a real implementation
    # For now, showing the structure

    echo -e "${CYAN}${BOLD}║${RESET} ${DIM}#01${RESET} Startup Performance                       ${GREEN}[✓]${RESET}      ${CYAN}30${RESET}     ${GREEN}100%${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${DIM}#02${RESET} Echo - Hardcore                           ${GREEN}[✓]${RESET}      ${CYAN}34${RESET}     ${GREEN}100%${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${DIM}#03${RESET} Echo - Extreme Cases                      ${GREEN}[✓]${RESET}      ${CYAN}13${RESET}     ${GREEN}100%${RESET} ${CYAN}${BOLD}║${RESET}"
    echo -e "${CYAN}${BOLD}║${RESET} ${DIM}...${RESET}                                                                      ${CYAN}${BOLD}║${RESET}"

    echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
}

show_failed_tests() {
    if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
        print_section "FAILED TESTS DETAILS"

        echo -e "${RED}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${RED}${BOLD}║${RESET}  ${WHITE}${BOLD}Found ${#FAILED_TESTS[@]} failed test(s) - Review required${RESET}                              ${RED}${BOLD}║${RESET}"
        echo -e "${RED}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"

        for i in "${!FAILED_TESTS[@]}"; do
            echo -e "${RED}${BOLD}╭─ Test #$((i+1))${RESET}"
            echo -e "${RED}${BOLD}│${RESET} ${FAILED_TESTS[$i]}"
            echo -e "${RED}${BOLD}│${RESET} ${DIM}Details: ${FAILED_DETAILS[$i]}${RESET}"
            echo -e "${RED}${BOLD}╰─${RESET}"
            echo ""
        done
        echo "" >> "$REPORT_FILE"
        echo "╔══════════════════════════════════════════════════════════════════════════╗" >> "$REPORT_FILE"
        echo "║                        FAILED TESTS DETAILS                              ║" >> "$REPORT_FILE"
        echo "╚══════════════════════════════════════════════════════════════════════════╝" >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"

        for i in "${!FAILED_TESTS[@]}"; do
            echo "$((i+1)). ${FAILED_TESTS[$i]}" >> "$REPORT_FILE"
            echo "   ${FAILED_DETAILS[$i]}" >> "$REPORT_FILE"
            echo "" >> "$REPORT_FILE"
        done
    else
        echo ""
        echo -e "${GREEN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${GREEN}${BOLD}║${RESET}  ${WHITE}${BOLD}✓ No Failed Tests - All tests passed successfully!${RESET}                   ${GREEN}${BOLD}║${RESET}"
        echo -e "${GREEN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"
    fi
}

show_summary() {
    print_section "FINAL SUMMARY"

    local pass_rate=0
    if [ $TESTS_TOTAL -gt 0 ]; then
        pass_rate=$((TESTS_PASSED * 100 / TESTS_TOTAL))
    fi

    local status_color=$GREEN
    local status_icon="✓"
    local status_text="EXCELLENT"
    local status_emoji="🎉"

    if [ $pass_rate -lt 100 ]; then
        status_color=$YELLOW
        status_icon="⚠"
        status_text="GOOD"
        status_emoji="👍"
    fi

    if [ $pass_rate -lt 80 ]; then
        status_color=$YELLOW
        status_icon="⚠"
        status_text="NEEDS WORK"
        status_emoji="⚠️"
    fi

    if [ $pass_rate -lt 60 ]; then
        status_color=$RED
        status_icon="✗"
        status_text="CRITICAL"
        status_emoji="❌"
    fi

    echo ""
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}║${RESET}${BOLD}                        TEST EXECUTION SUMMARY                            ${RESET}${CYAN}║${RESET}"
    echo -e "${CYAN}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${CYAN}║${RESET}                                                                          ${CYAN}║${RESET}"
    printf "${CYAN}║${RESET}   ${BOLD}Total Tests:${RESET}      ${WHITE}${BOLD}%6d${RESET}                                              ${CYAN}║${RESET}\n" $TESTS_TOTAL
    printf "${CYAN}║${RESET}   ${GREEN}${BOLD}✓ Tests Passed:${RESET}   ${GREEN}${BOLD}%6d${RESET}  ${DIM}(${GREEN}%3d%%${RESET}${DIM})${RESET}                                   ${CYAN}║${RESET}\n" $TESTS_PASSED $pass_rate

    local fail_rate=0
    if [ $TESTS_TOTAL -gt 0 ]; then
        fail_rate=$((TESTS_FAILED * 100 / TESTS_TOTAL))
    fi
    printf "${CYAN}║${RESET}   ${RED}${BOLD}✗ Tests Failed:${RESET}   ${RED}${BOLD}%6d${RESET}  ${DIM}(${RED}%3d%%${RESET}${DIM})${RESET}                                   ${CYAN}║${RESET}\n" $TESTS_FAILED $fail_rate
    printf "${CYAN}║${RESET}   ${YELLOW}${BOLD}⚠ Warnings:${RESET}       ${YELLOW}${BOLD}%6d${RESET}                                              ${CYAN}║${RESET}\n" $TEST_WARNINGS
    echo -e "${CYAN}║${RESET}                                                                          ${CYAN}║${RESET}"
    echo -e "${CYAN}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"

    # Visual progress bar
    echo -e "${CYAN}║${RESET}   ${BOLD}Success Rate:${RESET}                                                        ${CYAN}║${RESET}"

    local bar_width=60
    local filled=$((bar_width * TESTS_PASSED / TESTS_TOTAL))
    local empty=$((bar_width - filled))

    local bar_color=$GREEN
    if [ $pass_rate -lt 100 ]; then bar_color=$YELLOW; fi
    if [ $pass_rate -lt 80 ]; then bar_color=$YELLOW; fi
    if [ $pass_rate -lt 60 ]; then bar_color=$RED; fi

    printf "${CYAN}║${RESET}   ["
    printf "${bar_color}%${filled}s${RESET}" | tr ' ' '█'
    printf "${DIM}%${empty}s${RESET}" | tr ' ' '░'
    printf "] ${WHITE}${BOLD}%3d%%${RESET}   ${CYAN}║${RESET}\n" $pass_rate

    echo -e "${CYAN}║${RESET}                                                                          ${CYAN}║${RESET}"
    echo -e "${CYAN}╠══════════════════════════════════════════════════════════════════════════╣${RESET}"
    printf "${CYAN}║${RESET}   ${BOLD}Overall Status:${RESET}     ${status_color}${BOLD}%-15s${RESET}  ${status_emoji}                            ${CYAN}║${RESET}\n" "$status_icon $status_text"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════════════════╝${RESET}"

    # Additional visual stats
    draw_success_rate_bar $TESTS_PASSED $TESTS_TOTAL

    echo "" >> "$REPORT_FILE"
    echo "╔══════════════════════════════════════════════════════════════════════════╗" >> "$REPORT_FILE"
    echo "║                           SUMMARY                                        ║" >> "$REPORT_FILE"
    echo "╚══════════════════════════════════════════════════════════════════════════╝" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "Total tests:  $TESTS_TOTAL" >> "$REPORT_FILE"
    echo "Passed:       $TESTS_PASSED" >> "$REPORT_FILE"
    echo "Failed:       $TESTS_FAILED" >> "$REPORT_FILE"
    echo "Warnings:     $TEST_WARNINGS" >> "$REPORT_FILE"
    echo "Pass rate:    ${pass_rate}%" >> "$REPORT_FILE"
    echo "Status:       $status_text" >> "$REPORT_FILE"

    if [ $TESTS_FAILED -eq 0 ]; then
        echo ""
        echo -e "${GREEN}${BOLD}"
        cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════╗
║                                                                          ║
║          ███████╗██╗   ██╗ ██████╗ ██████╗███████╗███████╗███████╗      ║
║          ██╔════╝██║   ██║██╔════╝██╔════╝██╔════╝██╔════╝██╔════╝      ║
║          ███████╗██║   ██║██║     ██║     █████╗  ███████╗███████╗      ║
║          ╚════██║██║   ██║██║     ██║     ██╔══╝  ╚════██║╚════██║      ║
║          ███████║╚██████╔╝╚██████╗╚██████╗███████╗███████║███████║      ║
║          ╚══════╝ ╚═════╝  ╚═════╝ ╚═════╝╚══════╝╚══════╝╚══════╝      ║
║                                                                          ║
║                        🎉 ALL TESTS PASSED! 🎉                           ║
║                                                                          ║
║              Your minishell is performing EXCELLENTLY!                   ║
║                      Ready for production! 🚀                            ║
║                                                                          ║
╚══════════════════════════════════════════════════════════════════════════╝
EOF
        echo -e "${RESET}"

        echo "" >> "$REPORT_FILE"
        echo "🎉 ALL TESTS PASSED!" >> "$REPORT_FILE"
    elif [ $pass_rate -ge 80 ]; then
        echo ""
        echo -e "${YELLOW}${BOLD}"
        cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════╗
║                                                                          ║
║                         ⚠️  ALMOST THERE! ⚠️                              ║
║                                                                          ║
║                      SOME TESTS NEED ATTENTION                           ║
║                                                                          ║
║         Your minishell is looking good, but needs some fixes!            ║
║              Check the detailed report below. 👇                         ║
║                                                                          ║
╚══════════════════════════════════════════════════════════════════════════╝
EOF
        echo -e "${RESET}"

        echo "" >> "$REPORT_FILE"
        echo "⚠ Some tests failed - check details above" >> "$REPORT_FILE"
    else
        echo ""
        echo -e "${RED}${BOLD}"
        cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════╗
║                                                                          ║
║          ██████╗██████╗ ██╗████████╗██╗ ██████╗ █████╗ ██╗              ║
║         ██╔════╝██╔══██╗██║╚══██╔══╝██║██╔════╝██╔══██╗██║              ║
║         ██║     ██████╔╝██║   ██║   ██║██║     ███████║██║              ║
║         ██║     ██╔══██╗██║   ██║   ██║██║     ██╔══██║██║              ║
║         ╚██████╗██║  ██║██║   ██║   ██║╚██████╗██║  ██║███████╗         ║
║          ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝         ║
║                                                                          ║
║                   ❌ CRITICAL ISSUES DETECTED ❌                          ║
║                                                                          ║
║          Multiple tests failed. Immediate attention required!            ║
║               Review the detailed report below. 📋                       ║
║                                                                          ║
╚══════════════════════════════════════════════════════════════════════════╝
EOF
        echo -e "${RESET}"

        echo "" >> "$REPORT_FILE"
        echo "✗ Critical issues detected" >> "$REPORT_FILE"
    fi
}

view_report() {
    if [ -f "$REPORT_FILE" ]; then
        clear
        print_header
        print_section "Latest Report"
        cat "$REPORT_FILE" | head -150
        echo ""
        echo -e "${CYAN}Report location: ${YELLOW}${REPORT_FILE}${RESET}"
        echo -e "${DIM}(Showing first 150 lines - full report in file)${RESET}\n"
    else
        print_fail "No report found. Run a test first."
    fi
    echo -ne "${DIM}Press Enter to continue...${RESET}"
    read
}

# ============================================================================ #
#                                    MAIN                                      #
# ============================================================================ #

main() {
    check_minishell
    init_report

    while true; do
        clear
        show_menu
        read -r choice

        case $choice in
            1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|a|q|b|n)
                clear
                run_test "$choice"
                ;;
            h)
                show_help
                ;;
            l)
                show_categories_list
                ;;
            i)
                interactive_mode
                ;;
            c)
                browse_results_by_category
                ;;
            r)
                view_report
                ;;
            s)
                clear
                print_header
                show_summary
                show_failed_tests
                echo -ne "${DIM}Press Enter to continue...${RESET}"
                read
                ;;
            m)
                # Return to menu (do nothing, just loop)
                ;;
            x)
                clear
                echo ""
                echo -e "${GREEN}${BOLD}"
                cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════╗
║                                                                          ║
║                 _____ _                 _    __   __            _        ║
║                |_   _| |__   __ _ _ __ | | _\ \ / /__  _   _  | |       ║
║                  | | | '_ \ / _` | '_ \| |/ /\ V / _ \| | | | | |       ║
║                  | | | | | | (_| | | | |   <  | | (_) | |_| | |_|       ║
║                  |_| |_| |_|\__,_|_| |_|_|\_\ |_|\___/ \__,_| (_)       ║
║                                                                          ║
║              Thank you for using Minishell Benchmark v4.0!               ║
║                    Happy coding! 🚀                                      ║
║                                                                          ║
╚══════════════════════════════════════════════════════════════════════════╝
EOF
                echo -e "${RESET}\n"
                exit 0
                ;;
            *)
                # Invalid choice - show brief error
                echo -e "${RED}Invalid choice. Press 'h' for help.${RESET}"
                sleep 1
                ;;
        esac
    done
}

main
